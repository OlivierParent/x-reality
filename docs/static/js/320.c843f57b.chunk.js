(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[320],{4723:(e,t,r)=>{"use strict";r.d(t,{o:()=>f});var n=r(7462),o=r(5825),a=r(7313),i=r(9659),s=r.n(i);function l(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const n=new o.Vector3,a=new o.Quaternion,i=new o.Vector3,s=new o.Matrix4,l=new o.Matrix4,p=new o.Matrix4;r.preserveMatrix=void 0===r.preserveMatrix||r.preserveMatrix,r.preservePosition=void 0===r.preservePosition||r.preservePosition,r.preserveHipPosition=void 0!==r.preserveHipPosition&&r.preserveHipPosition,r.useTargetMatrix=void 0!==r.useTargetMatrix&&r.useTargetMatrix,r.hip=void 0!==r.hip?r.hip:"hip",r.names=r.names||{};const d=t.isObject3D?t.skeleton.bones:u(t),f=e.isObject3D?e.skeleton.bones:u(e);let h,m,g,v,y;if(e.isObject3D?e.skeleton.pose():(r.useTargetMatrix=!0,r.preserveMatrix=!1),r.preservePosition){y=[];for(let e=0;e<f.length;e++)y.push(f[e].position.clone())}if(r.preserveMatrix){e.updateMatrixWorld(),e.matrixWorld.identity();for(let t=0;t<e.children.length;++t)e.children[t].updateMatrixWorld(!0)}if(r.offsets){h=[];for(let e=0;e<f.length;++e)m=f[e],g=r.names[m.name]||m.name,r.offsets[g]&&(m.matrix.multiply(r.offsets[g]),m.matrix.decompose(m.position,m.quaternion,m.scale),m.updateMatrixWorld()),h.push(m.matrixWorld.clone())}for(let o=0;o<f.length;++o){if(m=f[o],g=r.names[m.name]||m.name,v=c(g,d),p.copy(m.matrixWorld),v){if(v.updateMatrixWorld(),r.useTargetMatrix?l.copy(v.matrixWorld):(l.copy(e.matrixWorld).invert(),l.multiply(v.matrixWorld)),i.setFromMatrixScale(l),l.scale(i.set(1/i.x,1/i.y,1/i.z)),p.makeRotationFromQuaternion(a.setFromRotationMatrix(l)),e.isObject3D){const t=f.indexOf(m),r=h?h[t]:s.copy(e.skeleton.boneInverses[t]).invert();p.multiply(r)}p.copyPosition(l)}m.parent&&m.parent.isBone?(m.matrix.copy(m.parent.matrixWorld).invert(),m.matrix.multiply(p)):m.matrix.copy(p),r.preserveHipPosition&&g===r.hip&&m.matrix.setPosition(n.set(0,m.position.y,0)),m.matrix.decompose(m.position,m.quaternion,m.scale),m.updateMatrixWorld()}if(r.preservePosition)for(let o=0;o<f.length;++o)m=f[o],g=r.names[m.name]||m.name,g!==r.hip&&m.position.copy(y[o]);r.preserveMatrix&&e.updateMatrixWorld(!0)}function c(e,t){for(let r=0,n=u(t);r<n.length;r++)if(e===n[r].name)return n[r]}function u(e){return Array.isArray(e)?e:e.bones}function p(e,t,r){r(e,t);for(let n=0;n<e.children.length;n++)p(e.children[n],t.children[n],r)}const d={retarget:l,retargetClip:function(e,t,r){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};n.useFirstFramePosition=void 0!==n.useFirstFramePosition&&n.useFirstFramePosition,n.fps=void 0!==n.fps?n.fps:30,n.names=n.names||[],t.isObject3D||(t=function(e){const t=new o.SkeletonHelper(e.bones[0]);return t.skeleton=e,t}(t));const a=Math.round(r.duration*(n.fps/1e3)*1e3),i=1/n.fps,s=[],p=new o.AnimationMixer(t),d=u(e.skeleton),f=[];let h,m,g,v,y;p.clipAction(r).play(),p.update(0),t.updateMatrixWorld();for(let o=0;o<a;++o){const r=o*i;l(e,t,n);for(let e=0;e<d.length;++e)y=n.names[d[e].name]||d[e].name,g=c(y,t.skeleton),g&&(m=d[e],v=f[e]=f[e]||{bone:m},n.hip===y&&(v.pos||(v.pos={times:new Float32Array(a),values:new Float32Array(3*a)}),n.useFirstFramePosition&&(0===o&&(h=m.position.clone()),m.position.sub(h)),v.pos.times[o]=r,m.position.toArray(v.pos.values,3*o)),v.quat||(v.quat={times:new Float32Array(a),values:new Float32Array(4*a)}),v.quat.times[o]=r,m.quaternion.toArray(v.quat.values,4*o));p.update(i),t.updateMatrixWorld()}for(let l=0;l<f.length;++l)v=f[l],v&&(v.pos&&s.push(new o.VectorKeyframeTrack(".bones["+v.bone.name+"].position",v.pos.times,v.pos.values)),s.push(new o.QuaternionKeyframeTrack(".bones["+v.bone.name+"].quaternion",v.quat.times,v.quat.values)));return p.uncacheAction(r),new o.AnimationClip(r.name,-1,s)},clone:function(e){const t=new Map,r=new Map,n=e.clone();return p(e,n,(function(e,n){t.set(n,e),r.set(e,n)})),n.traverse((function(e){if(!e.isSkinnedMesh)return;const n=e,o=t.get(e),a=o.skeleton.bones;n.skeleton=o.skeleton.clone(),n.bindMatrix.copy(o.bindMatrix),n.skeleton.bones=a.map((function(e){return r.get(e)})),n.bind(n.skeleton,n.bindMatrix)})),n}};const f=a.forwardRef(((e,t)=>{let{isChild:r=!1,object:i,children:l,deep:c,castShadow:u,receiveShadow:p,inject:h,keys:m,...g}=e;var v;const y={keys:m,deep:c,inject:h,castShadow:u,receiveShadow:p};if(i=a.useMemo((()=>{if(!1===r&&!Array.isArray(i)){let e=!1;if(i.traverse((t=>{t.isSkinnedMesh&&(e=!0)})),e)return d.clone(i)}return i}),[i,r]),Array.isArray(i))return a.createElement("group",(0,n.Z)({},g,{ref:t}),i.map((e=>a.createElement(f,(0,n.Z)({key:e.uuid,object:e},y)))),l);const{children:w,...x}=function(e,t){let{keys:r=["near","far","color","distance","decay","penumbra","angle","intensity","skeleton","visible","castShadow","receiveShadow","morphTargetDictionary","morphTargetInfluences","name","geometry","material","position","rotation","scale","up","userData","bindMode","bindMatrix","bindMatrixInverse","skeleton"],deep:n,inject:i,castShadow:l,receiveShadow:c}=t,u=s()(e,r);return n&&(u.geometry&&"materialsOnly"!==n&&(u.geometry=u.geometry.clone()),u.material&&"geometriesOnly"!==n&&(u.material=u.material.clone())),i&&(u="function"===typeof i?{...u,children:i(e)}:a.isValidElement(i)?{...u,children:i}:{...u,...i}),e instanceof o.Mesh&&(l&&(u.castShadow=!0),c&&(u.receiveShadow=!0)),u}(i,y),b=i.type[0].toLowerCase()+i.type.slice(1);return a.createElement(b,(0,n.Z)({},x,g,{ref:t}),(null==(v=i)?void 0:v.children).map((e=>"Bone"===e.type?a.createElement("primitive",(0,n.Z)({key:e.uuid,object:e},y)):a.createElement(f,(0,n.Z)({key:e.uuid,object:e},y,{isChild:!0})))),l,w)}))},3081:(e,t,r)=>{"use strict";r.d(t,{P:()=>p});var n=r(7462),o=r(7313),a=r(5825),i=r(9080),s=r(4296),l=r(2362);class c extends a.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new a.Vector3(0,0,0)},lightColor:{value:new a.Color("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new a.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      ",fragmentShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <".concat(l.i>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n      ")})}}function u(e){let{opacity:t=1,radiusTop:r,radiusBottom:n,depthBuffer:s,color:l="white",distance:u=5,angle:p=.15,attenuation:d=5,anglePower:f=5}=e;const h=o.useRef(null),m=(0,i.A)((e=>e.size)),g=(0,i.A)((e=>e.camera)),v=(0,i.A)((e=>e.viewport.dpr)),[y]=o.useState((()=>new c)),[w]=o.useState((()=>new a.Vector3));r=void 0===r?.1:r,n=void 0===n?7*p:n,(0,i.C)((()=>{y.uniforms.spotPosition.value.copy(h.current.getWorldPosition(w)),h.current.lookAt(h.current.parent.target.getWorldPosition(w))}));const x=o.useMemo((()=>{const e=new a.CylinderGeometry(r,n,u,128,64,!0);return e.applyMatrix4((new a.Matrix4).makeTranslation(0,-u/2,0)),e.applyMatrix4((new a.Matrix4).makeRotationX(-Math.PI/2)),e}),[u,r,n]);return o.createElement(o.Fragment,null,o.createElement("mesh",{ref:h,geometry:x,raycast:()=>null},o.createElement("primitive",{object:y,attach:"material","uniforms-opacity-value":t,"uniforms-lightColor-value":l,"uniforms-attenuation-value":d,"uniforms-anglePower-value":f,"uniforms-depth-value":s,"uniforms-cameraNear-value":g.near,"uniforms-cameraFar-value":g.far,"uniforms-resolution-value":s?[m.width*v,m.height*v]:[0,0]})))}const p=o.forwardRef(((e,t)=>{let{opacity:r=1,radiusTop:a,radiusBottom:i,depthBuffer:l,color:c="white",distance:p=5,angle:d=.15,attenuation:f=5,anglePower:h=5,volumetric:m=!0,debug:g=!1,children:v,...y}=e;const w=o.useRef(null);return o.createElement("group",null,g&&w.current&&o.createElement("spotLightHelper",{args:[w.current]}),o.createElement("spotLight",(0,n.Z)({ref:(0,s.Z)([t,w]),angle:d,color:c,distance:p,castShadow:!0},y),m&&o.createElement(u,{debug:g,opacity:r,radiusTop:a,radiusBottom:i,depthBuffer:l,color:c,distance:p,angle:d,attenuation:f,anglePower:h})),v&&o.cloneElement(v,{spotlightRef:w,debug:g}))}))},4511:(e,t,r)=>{"use strict";r.d(t,{D:()=>le});var n=r(5825),o=Uint8Array,a=Uint16Array,i=Uint32Array,s=new o([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),l=new o([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),c=new o([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),u=function(e,t){for(var r=new a(31),n=0;n<31;++n)r[n]=t+=1<<e[n-1];var o=new i(r[30]);for(n=1;n<30;++n)for(var s=r[n];s<r[n+1];++s)o[s]=s-r[n]<<5|n;return[r,o]},p=u(s,2),d=p[0],f=p[1];d[28]=258,f[258]=28;for(var h=u(l,0),m=h[0],g=(h[1],new a(32768)),v=0;v<32768;++v){var y=(43690&v)>>>1|(21845&v)<<1;y=(61680&(y=(52428&y)>>>2|(13107&y)<<2))>>>4|(3855&y)<<4,g[v]=((65280&y)>>>8|(255&y)<<8)>>>1}var w=function(e,t,r){for(var n=e.length,o=0,i=new a(t);o<n;++o)++i[e[o]-1];var s,l=new a(t);for(o=0;o<t;++o)l[o]=l[o-1]+i[o-1]<<1;if(r){s=new a(1<<t);var c=15-t;for(o=0;o<n;++o)if(e[o])for(var u=o<<4|e[o],p=t-e[o],d=l[e[o]-1]++<<p,f=d|(1<<p)-1;d<=f;++d)s[g[d]>>>c]=u}else for(s=new a(n),o=0;o<n;++o)e[o]&&(s[o]=g[l[e[o]-1]++]>>>15-e[o]);return s},x=new o(288);for(v=0;v<144;++v)x[v]=8;for(v=144;v<256;++v)x[v]=9;for(v=256;v<280;++v)x[v]=7;for(v=280;v<288;++v)x[v]=8;var b=new o(32);for(v=0;v<32;++v)b[v]=5;var M=w(x,9,1),I=w(b,5,1),P=function(e){for(var t=e[0],r=1;r<e.length;++r)e[r]>t&&(t=e[r]);return t},T=function(e,t,r){var n=t/8|0;return(e[n]|e[n+1]<<8)>>(7&t)&r},E=function(e,t){var r=t/8|0;return(e[r]|e[r+1]<<8|e[r+2]<<16)>>(7&t)},A=function(e){return(e/8|0)+(7&e&&1)},k=function(e,t,r){(null==t||t<0)&&(t=0),(null==r||r>e.length)&&(r=e.length);var n=new(e instanceof a?a:e instanceof i?i:o)(r-t);return n.set(e.subarray(t,r)),n},F=function(e,t,r){var n=e.length;if(!n||r&&!r.l&&n<5)return t||new o(0);var a=!t||r,i=!r||r.i;r||(r={}),t||(t=new o(3*n));var u=function(e){var r=t.length;if(e>r){var n=new o(Math.max(2*r,e));n.set(t),t=n}},p=r.f||0,f=r.p||0,h=r.b||0,g=r.l,v=r.d,y=r.m,x=r.n,b=8*n;do{if(!g){r.f=p=T(e,f,1);var F=T(e,f+1,3);if(f+=3,!F){var S=e[(U=A(f)+4)-4]|e[U-3]<<8,C=U+S;if(C>n){if(i)throw"unexpected EOF";break}a&&u(h+S),t.set(e.subarray(U,C),h),r.b=h+=S,r.p=f=8*C;continue}if(1==F)g=M,v=I,y=9,x=5;else{if(2!=F)throw"invalid block type";var D=T(e,f,31)+257,L=T(e,f+10,15)+4,N=D+T(e,f+5,31)+1;f+=14;for(var R=new o(N),O=new o(19),B=0;B<L;++B)O[c[B]]=T(e,f+3*B,7);f+=3*L;var j=P(O),V=(1<<j)-1,W=w(O,j,1);for(B=0;B<N;){var U,z=W[T(e,f,V)];if(f+=15&z,(U=z>>>4)<16)R[B++]=U;else{var G=0,X=0;for(16==U?(X=3+T(e,f,3),f+=2,G=R[B-1]):17==U?(X=3+T(e,f,7),f+=3):18==U&&(X=11+T(e,f,127),f+=7);X--;)R[B++]=G}}var _=R.subarray(0,D),H=R.subarray(D);y=P(_),x=P(H),g=w(_,y,1),v=w(H,x,1)}if(f>b){if(i)throw"unexpected EOF";break}}a&&u(h+131072);for(var Z=(1<<y)-1,K=(1<<x)-1,q=f;;q=f){var Y=(G=g[E(e,f)&Z])>>>4;if((f+=15&G)>b){if(i)throw"unexpected EOF";break}if(!G)throw"invalid length/literal";if(Y<256)t[h++]=Y;else{if(256==Y){q=f,g=null;break}var Q=Y-254;if(Y>264){var $=s[B=Y-257];Q=T(e,f,(1<<$)-1)+d[B],f+=$}var J=v[E(e,f)&K],ee=J>>>4;if(!J)throw"invalid distance";f+=15&J;H=m[ee];if(ee>3){$=l[ee];H+=E(e,f)&(1<<$)-1,f+=$}if(f>b){if(i)throw"unexpected EOF";break}a&&u(h+131072);for(var te=h+Q;h<te;h+=4)t[h]=t[h-H],t[h+1]=t[h+1-H],t[h+2]=t[h+2-H],t[h+3]=t[h+3-H];h=te}}r.l=g,r.p=q,r.b=h,g&&(p=1,r.m=y,r.d=v,r.n=x)}while(!p);return h==t.length?t:k(t,0,h)},S=new o(0),C=function(e){if(8!=(15&e[0])||e[0]>>>4>7||(e[0]<<8|e[1])%31)throw"invalid zlib data";if(32&e[1])throw"invalid zlib data: preset dictionaries not supported"};function D(e,t){return F((C(e),e.subarray(2,-4)),t)}var L="undefined"!=typeof TextDecoder&&new TextDecoder;try{L.decode(S,{stream:!0}),1}catch(ce){}function N(e,t,r){const n=r.length-e-1;if(t>=r[n])return n-1;if(t<=r[e])return e;let o=e,a=n,i=Math.floor((o+a)/2);for(;t<r[i]||t>=r[i+1];)t<r[i]?a=i:o=i,i=Math.floor((o+a)/2);return i}function R(e,t,r,n){const o=[],a=[],i=[];o[0]=1;for(let s=1;s<=r;++s){a[s]=t-n[e+1-s],i[s]=n[e+s]-t;let r=0;for(let e=0;e<s;++e){const t=i[e+1],n=a[s-e],l=o[e]/(t+n);o[e]=r+t*l,r=n*l}o[s]=r}return o}function O(e,t){let r=1;for(let o=2;o<=e;++o)r*=o;let n=1;for(let o=2;o<=t;++o)n*=o;for(let o=2;o<=e-t;++o)n*=o;return r/n}function B(e,t,r,o,a){const i=function(e,t,r,o,a){const i=a<e?a:e,s=[],l=N(e,o,t),c=function(e,t,r,n,o){const a=[];for(let p=0;p<=r;++p)a[p]=0;const i=[];for(let p=0;p<=n;++p)i[p]=a.slice(0);const s=[];for(let p=0;p<=r;++p)s[p]=a.slice(0);s[0][0]=1;const l=a.slice(0),c=a.slice(0);for(let p=1;p<=r;++p){l[p]=t-o[e+1-p],c[p]=o[e+p]-t;let r=0;for(let e=0;e<p;++e){const t=c[e+1],n=l[p-e];s[p][e]=t+n;const o=s[e][p-1]/s[p][e];s[e][p]=r+t*o,r=n*o}s[p][p]=r}for(let p=0;p<=r;++p)i[0][p]=s[p][r];for(let p=0;p<=r;++p){let e=0,t=1;const o=[];for(let n=0;n<=r;++n)o[n]=a.slice(0);o[0][0]=1;for(let a=1;a<=n;++a){let n=0;const l=p-a,c=r-a;p>=a&&(o[t][0]=o[e][0]/s[c+1][l],n=o[t][0]*s[l][c]);const u=p-1<=c?a-1:r-p;for(let r=l>=-1?1:-l;r<=u;++r)o[t][r]=(o[e][r]-o[e][r-1])/s[c+1][l+r],n+=o[t][r]*s[l+r][c];p<=c&&(o[t][a]=-o[e][a-1]/s[c+1][p],n+=o[t][a]*s[p][c]),i[a][p]=n;const d=e;e=t,t=d}}let u=r;for(let p=1;p<=n;++p){for(let e=0;e<=r;++e)i[p][e]*=u;u*=r-p}return i}(l,o,e,i,t),u=[];for(let n=0;n<r.length;++n){const e=r[n].clone(),t=e.w;e.x*=t,e.y*=t,e.z*=t,u[n]=e}for(let n=0;n<=i;++n){const t=u[l-e].clone().multiplyScalar(c[n][0]);for(let r=1;r<=e;++r)t.add(u[l-e+r].clone().multiplyScalar(c[n][r]));s[n]=t}for(let p=i+1;p<=a+1;++p)s[p]=new n.Vector4(0,0,0);return s}(e,t,r,o,a);return function(e){const t=e.length,r=[],o=[];for(let i=0;i<t;++i){const t=e[i];r[i]=new n.Vector3(t.x,t.y,t.z),o[i]=t.w}const a=[];for(let n=0;n<t;++n){const e=r[n].clone();for(let t=1;t<=n;++t)e.sub(a[n-t].clone().multiplyScalar(O(n,t)*o[t]));a[n]=e.divideScalar(o[0])}return a}(i)}class j extends n.Curve{constructor(e,t,r,o,a){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=o||0,this.endKnot=a||this.knots.length-1;for(let i=0;i<r.length;++i){const e=r[i];this.controlPoints[i]=new n.Vector4(e.x,e.y,e.z,e.w)}}getPoint(e,t){const r=t||new n.Vector3,o=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),a=function(e,t,r,o){const a=N(e,o,t),i=R(a,o,e,t),s=new n.Vector4(0,0,0,0);for(let n=0;n<=e;++n){const t=r[a-e+n],o=i[n],l=t.w*o;s.x+=t.x*l,s.y+=t.y*l,s.z+=t.z*l,s.w+=t.w*o}return s}(this.degree,this.knots,this.controlPoints,o);return 1!=a.w&&a.divideScalar(a.w),r.set(a.x,a.y,a.z)}getTangent(e,t){const r=t||new n.Vector3,o=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),a=B(this.degree,this.knots,this.controlPoints,o,1);return r.copy(a[1]).normalize(),r}}let V,W,U;class z extends n.Loader{constructor(e){super(e)}load(e,t,r,o){const a=this,i=""===a.path?n.LoaderUtils.extractUrlBase(e):a.path,s=new n.FileLoader(this.manager);s.setPath(a.path),s.setResponseType("arraybuffer"),s.setRequestHeader(a.requestHeader),s.setWithCredentials(a.withCredentials),s.load(e,(function(r){try{t(a.parse(r,i))}catch(ce){o?o(ce):console.error(ce),a.manager.itemError(e)}}),r,o)}parse(e,t){if(function(e){const t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===ae(e,0,t.length)}(e))V=(new Z).parse(e);else{const t=ae(e);if(!function(e){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let r=0;function n(t){const n=e[t-1];return e=e.slice(r+t),r++,n}for(let o=0;o<t.length;++o){if(n(1)===t[o])return!1}return!0}(t))throw new Error("THREE.FBXLoader: Unknown format.");if(Y(t)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Y(t));V=(new H).parse(t)}const r=new n.TextureLoader(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new G(r,this.manager).parse(V)}}class G{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){W=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),r=this.parseMaterials(t),n=this.parseDeformers(),o=(new X).parse(n);return this.parseScene(n,o,r),U}parseConnections(){const e=new Map;if("Connections"in V){V.Connections.connections.forEach((function(t){const r=t[0],n=t[1],o=t[2];e.has(r)||e.set(r,{parents:[],children:[]});const a={ID:n,relationship:o};e.get(r).parents.push(a),e.has(n)||e.set(n,{parents:[],children:[]});const i={ID:r,relationship:o};e.get(n).children.push(i)}))}return e}parseImages(){const e={},t={};if("Video"in V.Objects){const r=V.Objects.Video;for(const n in r){const o=r[n];if(e[parseInt(n)]=o.RelativeFilename||o.Filename,"Content"in o){const e=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,a="string"===typeof o.Content&&""!==o.Content;if(e||a){const e=this.parseImage(r[n]);t[o.RelativeFilename||o.Filename]=e}}}}for(const r in e){const n=e[r];void 0!==t[n]?e[r]=t[n]:e[r]=e[r].split("\\").pop()}return e}parseImage(e){const t=e.Content,r=e.RelativeFilename||e.Filename,n=r.slice(r.lastIndexOf(".")+1).toLowerCase();let o;switch(n){case"bmp":o="image/bmp";break;case"jpg":case"jpeg":o="image/jpeg";break;case"png":o="image/png";break;case"tif":o="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",r),o="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+n+'" is not supported.')}if("string"===typeof t)return"data:"+o+";base64,"+t;{const e=new Uint8Array(t);return window.URL.createObjectURL(new Blob([e],{type:o}))}}parseTextures(e){const t=new Map;if("Texture"in V.Objects){const r=V.Objects.Texture;for(const n in r){const o=this.parseTexture(r[n],e);t.set(parseInt(n),o)}}return t}parseTexture(e,t){const r=this.loadTexture(e,t);r.ID=e.id,r.name=e.attrName;const o=e.WrapModeU,a=e.WrapModeV,i=void 0!==o?o.value:0,s=void 0!==a?a.value:0;if(r.wrapS=0===i?n.RepeatWrapping:n.ClampToEdgeWrapping,r.wrapT=0===s?n.RepeatWrapping:n.ClampToEdgeWrapping,"Scaling"in e){const t=e.Scaling.value;r.repeat.x=t[0],r.repeat.y=t[1]}return r}loadTexture(e,t){let r;const o=this.textureLoader.path,a=W.get(e.id).children;let i;void 0!==a&&a.length>0&&void 0!==t[a[0].ID]&&(r=t[a[0].ID],0!==r.indexOf("blob:")&&0!==r.indexOf("data:")||this.textureLoader.setPath(void 0));const s=e.FileName.slice(-3).toLowerCase();if("tga"===s){const t=this.manager.getHandler(".tga");null===t?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),i=new n.Texture):(t.setPath(this.textureLoader.path),i=t.load(r))}else"psd"===s?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),i=new n.Texture):i=this.textureLoader.load(r);return this.textureLoader.setPath(o),i}parseMaterials(e){const t=new Map;if("Material"in V.Objects){const r=V.Objects.Material;for(const n in r){const o=this.parseMaterial(r[n],e);null!==o&&t.set(parseInt(n),o)}}return t}parseMaterial(e,t){const r=e.id,o=e.attrName;let a=e.ShadingModel;if("object"===typeof a&&(a=a.value),!W.has(r))return null;const i=this.parseParameters(e,t,r);let s;switch(a.toLowerCase()){case"phong":s=new n.MeshPhongMaterial;break;case"lambert":s=new n.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',a),s=new n.MeshPhongMaterial}return s.setValues(i),s.name=o,s}parseParameters(e,t,r){const o={};e.BumpFactor&&(o.bumpScale=e.BumpFactor.value),e.Diffuse?o.color=(new n.Color).fromArray(e.Diffuse.value):!e.DiffuseColor||"Color"!==e.DiffuseColor.type&&"ColorRGB"!==e.DiffuseColor.type||(o.color=(new n.Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(o.displacementScale=e.DisplacementFactor.value),e.Emissive?o.emissive=(new n.Color).fromArray(e.Emissive.value):!e.EmissiveColor||"Color"!==e.EmissiveColor.type&&"ColorRGB"!==e.EmissiveColor.type||(o.emissive=(new n.Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(o.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(o.opacity=parseFloat(e.Opacity.value)),o.opacity<1&&(o.transparent=!0),e.ReflectionFactor&&(o.reflectivity=e.ReflectionFactor.value),e.Shininess&&(o.shininess=e.Shininess.value),e.Specular?o.specular=(new n.Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(o.specular=(new n.Color).fromArray(e.SpecularColor.value));const a=this;return W.get(r).children.forEach((function(e){const r=e.relationship;switch(r){case"Bump":o.bumpMap=a.getTexture(t,e.ID);break;case"Maya|TEX_ao_map":o.aoMap=a.getTexture(t,e.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=a.getTexture(t,e.ID),void 0!==o.map&&("colorSpace"in o.map?o.map.colorSpace="srgb":o.map.encoding=3001);break;case"DisplacementColor":o.displacementMap=a.getTexture(t,e.ID);break;case"EmissiveColor":o.emissiveMap=a.getTexture(t,e.ID),void 0!==o.emissiveMap&&("colorSpace"in o.emissiveMap?o.emissiveMap.colorSpace="srgb":o.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=a.getTexture(t,e.ID);break;case"ReflectionColor":o.envMap=a.getTexture(t,e.ID),void 0!==o.envMap&&(o.envMap.mapping=n.EquirectangularReflectionMapping,"colorSpace"in o.envMap?o.envMap.colorSpace="srgb":o.envMap.encoding=3001);break;case"SpecularColor":o.specularMap=a.getTexture(t,e.ID),void 0!==o.specularMap&&("colorSpace"in o.specularMap?o.specularMap.colorSpace="srgb":o.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=a.getTexture(t,e.ID),o.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",r)}})),o}getTexture(e,t){return"LayeredTexture"in V.Objects&&t in V.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=W.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in V.Objects){const r=V.Objects.Deformer;for(const n in r){const o=r[n],a=W.get(parseInt(n));if("Skin"===o.attrType){const t=this.parseSkeleton(a,r);t.ID=n,a.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),t.geometryID=a.parents[0].ID,e[n]=t}else if("BlendShape"===o.attrType){const e={id:n};e.rawTargets=this.parseMorphTargets(a,r),e.id=n,a.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=e}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const r=[];return e.children.forEach((function(e){const o=t[e.ID];if("Cluster"!==o.attrType)return;const a={ID:e.ID,indices:[],weights:[],transformLink:(new n.Matrix4).fromArray(o.TransformLink.a)};"Indexes"in o&&(a.indices=o.Indexes.a,a.weights=o.Weights.a),r.push(a)})),{rawBones:r,bones:[]}}parseMorphTargets(e,t){const r=[];for(let n=0;n<e.children.length;n++){const o=e.children[n],a=t[o.ID],i={name:a.attrName,initialWeight:a.DeformPercent,id:a.id,fullWeights:a.FullWeights.a};if("BlendShapeChannel"!==a.attrType)return;i.geoID=W.get(parseInt(o.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,r.push(i)}return r}parseScene(e,t,r){U=new n.Group;const o=this.parseModels(e.skeletons,t,r),a=V.Objects.Model,i=this;o.forEach((function(e){const t=a[e.ID];i.setLookAtProperties(e,t);W.get(e.ID).parents.forEach((function(t){const r=o.get(t.ID);void 0!==r&&r.add(e)})),null===e.parent&&U.add(e)})),this.bindSkeleton(e.skeletons,t,o),this.createAmbientLight(),U.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld);const t=re(e.userData.transformData);e.applyMatrix4(t),e.updateWorldMatrix()}}));const s=(new _).parse();1===U.children.length&&U.children[0].isGroup&&(U.children[0].animations=s,U=U.children[0]),U.animations=s}parseModels(e,t,r){const o=new Map,a=V.Objects.Model;for(const i in a){const s=parseInt(i),l=a[i],c=W.get(s);let u=this.buildSkeleton(c,e,s,l.attrName);if(!u){switch(l.attrType){case"Camera":u=this.createCamera(c);break;case"Light":u=this.createLight(c);break;case"Mesh":u=this.createMesh(c,t,r);break;case"NurbsCurve":u=this.createCurve(c,t);break;case"LimbNode":case"Root":u=new n.Bone;break;default:u=new n.Group}u.name=l.attrName?n.PropertyBinding.sanitizeNodeName(l.attrName):"",u.ID=s}this.getTransformData(u,l),o.set(s,u)}return o}buildSkeleton(e,t,r,o){let a=null;return e.parents.forEach((function(e){for(const i in t){const s=t[i];s.rawBones.forEach((function(t,i){if(t.ID===e.ID){const e=a;a=new n.Bone,a.matrixWorld.copy(t.transformLink),a.name=o?n.PropertyBinding.sanitizeNodeName(o):"",a.ID=r,s.bones[i]=a,null!==e&&a.add(e)}}))}})),a}createCamera(e){let t,r;if(e.children.forEach((function(e){const t=V.Objects.NodeAttribute[e.ID];void 0!==t&&(r=t)})),void 0===r)t=new n.Object3D;else{let e=0;void 0!==r.CameraProjectionType&&1===r.CameraProjectionType.value&&(e=1);let o=1;void 0!==r.NearPlane&&(o=r.NearPlane.value/1e3);let a=1e3;void 0!==r.FarPlane&&(a=r.FarPlane.value/1e3);let i=window.innerWidth,s=window.innerHeight;void 0!==r.AspectWidth&&void 0!==r.AspectHeight&&(i=r.AspectWidth.value,s=r.AspectHeight.value);const l=i/s;let c=45;void 0!==r.FieldOfView&&(c=r.FieldOfView.value);const u=r.FocalLength?r.FocalLength.value:null;switch(e){case 0:t=new n.PerspectiveCamera(c,l,o,a),null!==u&&t.setFocalLength(u);break;case 1:t=new n.OrthographicCamera(-i/2,i/2,s/2,-s/2,o,a);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+e+"."),t=new n.Object3D}}return t}createLight(e){let t,r;if(e.children.forEach((function(e){const t=V.Objects.NodeAttribute[e.ID];void 0!==t&&(r=t)})),void 0===r)t=new n.Object3D;else{let e;e=void 0===r.LightType?0:r.LightType.value;let o=16777215;void 0!==r.Color&&(o=(new n.Color).fromArray(r.Color.value));let a=void 0===r.Intensity?1:r.Intensity.value/100;void 0!==r.CastLightOnObject&&0===r.CastLightOnObject.value&&(a=0);let i=0;void 0!==r.FarAttenuationEnd&&(i=void 0!==r.EnableFarAttenuation&&0===r.EnableFarAttenuation.value?0:r.FarAttenuationEnd.value);const s=1;switch(e){case 0:t=new n.PointLight(o,a,i,s);break;case 1:t=new n.DirectionalLight(o,a);break;case 2:let e=Math.PI/3;void 0!==r.InnerAngle&&(e=n.MathUtils.degToRad(r.InnerAngle.value));let l=0;void 0!==r.OuterAngle&&(l=n.MathUtils.degToRad(r.OuterAngle.value),l=Math.max(l,1)),t=new n.SpotLight(o,a,i,e,l,s);break;default:console.warn("THREE.FBXLoader: Unknown light type "+r.LightType.value+", defaulting to a PointLight."),t=new n.PointLight(o,a)}void 0!==r.CastShadows&&1===r.CastShadows.value&&(t.castShadow=!0)}return t}createMesh(e,t,r){let o,a=null,i=null;const s=[];return e.children.forEach((function(e){t.has(e.ID)&&(a=t.get(e.ID)),r.has(e.ID)&&s.push(r.get(e.ID))})),s.length>1?i=s:s.length>0?i=s[0]:(i=new n.MeshPhongMaterial({color:13421772}),s.push(i)),"color"in a.attributes&&s.forEach((function(e){e.vertexColors=!0})),a.FBX_Deformer?(o=new n.SkinnedMesh(a,i),o.normalizeSkinWeights()):o=new n.Mesh(a,i),o}createCurve(e,t){const r=e.children.reduce((function(e,r){return t.has(r.ID)&&(e=t.get(r.ID)),e}),null),o=new n.LineBasicMaterial({color:3342591,linewidth:1});return new n.Line(r,o)}getTransformData(e,t){const r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),r.eulerOrder="RotationOrder"in t?ne(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r}setLookAtProperties(e,t){if("LookAtProperty"in t){W.get(e.ID).children.forEach((function(t){if("LookAtProperty"===t.relationship){const r=V.Objects.Model[t.ID];if("Lcl_Translation"in r){const t=r.Lcl_Translation.value;void 0!==e.target?(e.target.position.fromArray(t),U.add(e.target)):e.lookAt((new n.Vector3).fromArray(t))}}}))}}bindSkeleton(e,t,r){const o=this.parsePoseNodes();for(const a in e){const i=e[a];W.get(parseInt(i.ID)).parents.forEach((function(e){if(t.has(e.ID)){const t=e.ID;W.get(t).parents.forEach((function(e){if(r.has(e.ID)){r.get(e.ID).bind(new n.Skeleton(i.bones),o[e.ID])}}))}}))}}parsePoseNodes(){const e={};if("Pose"in V.Objects){const t=V.Objects.Pose;for(const r in t)if("BindPose"===t[r].attrType&&t[r].NbPoseNodes>0){const o=t[r].PoseNode;Array.isArray(o)?o.forEach((function(t){e[t.Node]=(new n.Matrix4).fromArray(t.Matrix.a)})):e[o.Node]=(new n.Matrix4).fromArray(o.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in V&&"AmbientColor"in V.GlobalSettings){const e=V.GlobalSettings.AmbientColor.value,t=e[0],r=e[1],o=e[2];if(0!==t||0!==r||0!==o){const e=new n.Color(t,r,o);U.add(new n.AmbientLight(e,1))}}}}class X{parse(e){const t=new Map;if("Geometry"in V.Objects){const r=V.Objects.Geometry;for(const n in r){const o=W.get(parseInt(n)),a=this.parseGeometry(o,r[n],e);t.set(parseInt(n),a)}}return t}parseGeometry(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,r){const n=r.skeletons,o=[],a=e.parents.map((function(e){return V.Objects.Model[e.ID]}));if(0===a.length)return;const i=e.children.reduce((function(e,t){return void 0!==n[t.ID]&&(e=n[t.ID]),e}),null);e.children.forEach((function(e){void 0!==r.morphTargets[e.ID]&&o.push(r.morphTargets[e.ID])}));const s=a[0],l={};"RotationOrder"in s&&(l.eulerOrder=ne(s.RotationOrder.value)),"InheritType"in s&&(l.inheritType=parseInt(s.InheritType.value)),"GeometricTranslation"in s&&(l.translation=s.GeometricTranslation.value),"GeometricRotation"in s&&(l.rotation=s.GeometricRotation.value),"GeometricScaling"in s&&(l.scale=s.GeometricScaling.value);const c=re(l);return this.genGeometry(t,i,o,c)}genGeometry(e,t,r,o){const a=new n.BufferGeometry;e.attrName&&(a.name=e.attrName);const i=this.parseGeoNode(e,t),s=this.genBuffers(i),l=new n.Float32BufferAttribute(s.vertex,3);if(l.applyMatrix4(o),a.setAttribute("position",l),s.colors.length>0&&a.setAttribute("color",new n.Float32BufferAttribute(s.colors,3)),t&&(a.setAttribute("skinIndex",new n.Uint16BufferAttribute(s.weightsIndices,4)),a.setAttribute("skinWeight",new n.Float32BufferAttribute(s.vertexWeights,4)),a.FBX_Deformer=t),s.normal.length>0){const e=(new n.Matrix3).getNormalMatrix(o),t=new n.Float32BufferAttribute(s.normal,3);t.applyNormalMatrix(e),a.setAttribute("normal",t)}if(s.uvs.forEach((function(e,t){let r="uv"+(t+1).toString();0===t&&(r="uv"),a.setAttribute(r,new n.Float32BufferAttribute(s.uvs[t],2))})),i.material&&"AllSame"!==i.material.mappingType){let e=s.materialIndex[0],t=0;if(s.materialIndex.forEach((function(r,n){r!==e&&(a.addGroup(t,n-t,e),e=r,t=n)})),a.groups.length>0){const t=a.groups[a.groups.length-1],r=t.start+t.count;r!==s.materialIndex.length&&a.addGroup(r,s.materialIndex.length-r,e)}0===a.groups.length&&a.addGroup(0,s.materialIndex.length,s.materialIndex[0])}return this.addMorphTargets(a,e,r,o),a}parseGeoNode(e,t){const r={};if(r.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],r.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(r.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(r.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(r.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){r.uv=[];let t=0;for(;e.LayerElementUV[t];)e.LayerElementUV[t].UV&&r.uv.push(this.parseUVs(e.LayerElementUV[t])),t++}return r.weightTable={},null!==t&&(r.skeleton=t,t.rawBones.forEach((function(e,t){e.indices.forEach((function(n,o){void 0===r.weightTable[n]&&(r.weightTable[n]=[]),r.weightTable[n].push({id:t,weight:e.weights[o]})}))}))),r}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let r=0,n=0,o=!1,a=[],i=[],s=[],l=[],c=[],u=[];const p=this;return e.vertexIndices.forEach((function(d,f){let h,m=!1;d<0&&(d^=-1,m=!0);let g=[],v=[];if(a.push(3*d,3*d+1,3*d+2),e.color){const t=J(f,r,d,e.color);s.push(t[0],t[1],t[2])}if(e.skeleton){if(void 0!==e.weightTable[d]&&e.weightTable[d].forEach((function(e){v.push(e.weight),g.push(e.id)})),v.length>4){o||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),o=!0);const e=[0,0,0,0],t=[0,0,0,0];v.forEach((function(r,n){let o=r,a=g[n];t.forEach((function(t,r,n){if(o>t){n[r]=o,o=t;const i=e[r];e[r]=a,a=i}}))})),g=e,v=t}for(;v.length<4;)v.push(0),g.push(0);for(let e=0;e<4;++e)c.push(v[e]),u.push(g[e])}if(e.normal){const t=J(f,r,d,e.normal);i.push(t[0],t[1],t[2])}e.material&&"AllSame"!==e.material.mappingType&&(h=J(f,r,d,e.material)[0]),e.uv&&e.uv.forEach((function(e,t){const n=J(f,r,d,e);void 0===l[t]&&(l[t]=[]),l[t].push(n[0]),l[t].push(n[1])})),n++,m&&(p.genFace(t,e,a,h,i,s,l,c,u,n),r++,n=0,a=[],i=[],s=[],l=[],c=[],u=[])})),t}genFace(e,t,r,n,o,a,i,s,l,c){for(let u=2;u<c;u++)e.vertex.push(t.vertexPositions[r[0]]),e.vertex.push(t.vertexPositions[r[1]]),e.vertex.push(t.vertexPositions[r[2]]),e.vertex.push(t.vertexPositions[r[3*(u-1)]]),e.vertex.push(t.vertexPositions[r[3*(u-1)+1]]),e.vertex.push(t.vertexPositions[r[3*(u-1)+2]]),e.vertex.push(t.vertexPositions[r[3*u]]),e.vertex.push(t.vertexPositions[r[3*u+1]]),e.vertex.push(t.vertexPositions[r[3*u+2]]),t.skeleton&&(e.vertexWeights.push(s[0]),e.vertexWeights.push(s[1]),e.vertexWeights.push(s[2]),e.vertexWeights.push(s[3]),e.vertexWeights.push(s[4*(u-1)]),e.vertexWeights.push(s[4*(u-1)+1]),e.vertexWeights.push(s[4*(u-1)+2]),e.vertexWeights.push(s[4*(u-1)+3]),e.vertexWeights.push(s[4*u]),e.vertexWeights.push(s[4*u+1]),e.vertexWeights.push(s[4*u+2]),e.vertexWeights.push(s[4*u+3]),e.weightsIndices.push(l[0]),e.weightsIndices.push(l[1]),e.weightsIndices.push(l[2]),e.weightsIndices.push(l[3]),e.weightsIndices.push(l[4*(u-1)]),e.weightsIndices.push(l[4*(u-1)+1]),e.weightsIndices.push(l[4*(u-1)+2]),e.weightsIndices.push(l[4*(u-1)+3]),e.weightsIndices.push(l[4*u]),e.weightsIndices.push(l[4*u+1]),e.weightsIndices.push(l[4*u+2]),e.weightsIndices.push(l[4*u+3])),t.color&&(e.colors.push(a[0]),e.colors.push(a[1]),e.colors.push(a[2]),e.colors.push(a[3*(u-1)]),e.colors.push(a[3*(u-1)+1]),e.colors.push(a[3*(u-1)+2]),e.colors.push(a[3*u]),e.colors.push(a[3*u+1]),e.colors.push(a[3*u+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(o[0]),e.normal.push(o[1]),e.normal.push(o[2]),e.normal.push(o[3*(u-1)]),e.normal.push(o[3*(u-1)+1]),e.normal.push(o[3*(u-1)+2]),e.normal.push(o[3*u]),e.normal.push(o[3*u+1]),e.normal.push(o[3*u+2])),t.uv&&t.uv.forEach((function(t,r){void 0===e.uvs[r]&&(e.uvs[r]=[]),e.uvs[r].push(i[r][0]),e.uvs[r].push(i[r][1]),e.uvs[r].push(i[r][2*(u-1)]),e.uvs[r].push(i[r][2*(u-1)+1]),e.uvs[r].push(i[r][2*u]),e.uvs[r].push(i[r][2*u+1])}))}addMorphTargets(e,t,r,n){if(0===r.length)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const o=this;r.forEach((function(r){r.rawTargets.forEach((function(r){const a=V.Objects.Geometry[r.geoID];void 0!==a&&o.genMorphGeometry(e,t,a,n,r.name)}))}))}genMorphGeometry(e,t,r,o,a){const i=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],s=void 0!==r.Vertices?r.Vertices.a:[],l=void 0!==r.Indexes?r.Indexes.a:[],c=3*e.attributes.position.count,u=new Float32Array(c);for(let n=0;n<l.length;n++){const e=3*l[n];u[e]=s[3*n],u[e+1]=s[3*n+1],u[e+2]=s[3*n+2]}const p={vertexIndices:i,vertexPositions:u},d=this.genBuffers(p),f=new n.Float32BufferAttribute(d.vertex,3);f.name=a||r.attrName,f.applyMatrix4(o),e.morphAttributes.position.push(f)}parseNormals(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Normals.a;let o=[];return"IndexToDirect"===r&&("NormalIndex"in e?o=e.NormalIndex.a:"NormalsIndex"in e&&(o=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:o,mappingType:t,referenceType:r}}parseUVs(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.UV.a;let o=[];return"IndexToDirect"===r&&(o=e.UVIndex.a),{dataSize:2,buffer:n,indices:o,mappingType:t,referenceType:r}}parseVertexColors(e){const t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Colors.a;let o=[];return"IndexToDirect"===r&&(o=e.ColorIndex.a),{dataSize:4,buffer:n,indices:o,mappingType:t,referenceType:r}}parseMaterialIndices(e){const t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};const n=e.Materials.a,o=[];for(let a=0;a<n.length;++a)o.push(a);return{dataSize:1,buffer:n,indices:o,mappingType:t,referenceType:r}}parseNurbsGeometry(e){if(void 0===j)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new n.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new n.BufferGeometry;const r=t-1,o=e.KnotVector.a,a=[],i=e.Points.a;for(let u=0,p=i.length;u<p;u+=4)a.push((new n.Vector4).fromArray(i,u));let s,l;if("Closed"===e.Form)a.push(a[0]);else if("Periodic"===e.Form){s=r,l=o.length-1-s;for(let e=0;e<r;++e)a.push(a[e])}const c=new j(r,o,a,s,l).getPoints(12*a.length);return(new n.BufferGeometry).setFromPoints(c)}}class _{parse(){const e=[],t=this.parseClips();if(void 0!==t)for(const r in t){const n=t[r],o=this.addClip(n);e.push(o)}return e}parseClips(){if(void 0===V.Objects.AnimationCurve)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=V.Objects.AnimationCurveNode,t=new Map;for(const r in e){const n=e[r];if(null!==n.attrName.match(/S|R|T|DeformPercent/)){const e={id:n.id,attr:n.attrName,curves:{}};t.set(e.id,e)}}return t}parseAnimationCurves(e){const t=V.Objects.AnimationCurve;for(const r in t){const n={id:t[r].id,times:t[r].KeyTime.a.map(Q),values:t[r].KeyValueFloat.a},o=W.get(n.id);if(void 0!==o){const t=o.parents[0].ID,r=o.parents[0].relationship;r.match(/X/)?e.get(t).curves.x=n:r.match(/Y/)?e.get(t).curves.y=n:r.match(/Z/)?e.get(t).curves.z=n:r.match(/d|DeformPercent/)&&e.has(t)&&(e.get(t).curves.morph=n)}}}parseAnimationLayers(e){const t=V.Objects.AnimationLayer,r=new Map;for(const o in t){const t=[],a=W.get(parseInt(o));if(void 0!==a){a.children.forEach((function(r,o){if(e.has(r.ID)){const a=e.get(r.ID);if(void 0!==a.curves.x||void 0!==a.curves.y||void 0!==a.curves.z){if(void 0===t[o]){const e=W.get(r.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID;if(void 0!==e){const a=V.Objects.Model[e.toString()];if(void 0===a)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",r);const i={modelName:a.attrName?n.PropertyBinding.sanitizeNodeName(a.attrName):"",ID:a.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};U.traverse((function(e){e.ID===a.id&&(i.transform=e.matrix,e.userData.transformData&&(i.eulerOrder=e.userData.transformData.eulerOrder))})),i.transform||(i.transform=new n.Matrix4),"PreRotation"in a&&(i.preRotation=a.PreRotation.value),"PostRotation"in a&&(i.postRotation=a.PostRotation.value),t[o]=i}}t[o]&&(t[o][a.attr]=a)}else if(void 0!==a.curves.morph){if(void 0===t[o]){const e=W.get(r.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,a=W.get(e).parents[0].ID,i=W.get(a).parents[0].ID,s=W.get(i).parents[0].ID,l=V.Objects.Model[s],c={modelName:l.attrName?n.PropertyBinding.sanitizeNodeName(l.attrName):"",morphName:V.Objects.Deformer[e].attrName};t[o]=c}t[o][a.attr]=a}}})),r.set(parseInt(o),t)}}return r}parseAnimStacks(e){const t=V.Objects.AnimationStack,r={};for(const n in t){const o=W.get(parseInt(n)).children;o.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const a=e.get(o[0].ID);r[n]={name:t[n].attrName,layer:a}}return r}addClip(e){let t=[];const r=this;return e.layer.forEach((function(e){t=t.concat(r.generateTracks(e))})),new n.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let r=new n.Vector3,o=new n.Quaternion,a=new n.Vector3;if(e.transform&&e.transform.decompose(r,o,a),r=r.toArray(),o=(new n.Euler).setFromQuaternion(o,e.eulerOrder).toArray(),a=a.toArray(),void 0!==e.T&&Object.keys(e.T.curves).length>0){const n=this.generateVectorTrack(e.modelName,e.T.curves,r,"position");void 0!==n&&t.push(n)}if(void 0!==e.R&&Object.keys(e.R.curves).length>0){const r=this.generateRotationTrack(e.modelName,e.R.curves,o,e.preRotation,e.postRotation,e.eulerOrder);void 0!==r&&t.push(r)}if(void 0!==e.S&&Object.keys(e.S.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.S.curves,a,"scale");void 0!==r&&t.push(r)}if(void 0!==e.DeformPercent){const r=this.generateMorphTrack(e);void 0!==r&&t.push(r)}return t}generateVectorTrack(e,t,r,o){const a=this.getTimesForAllAxes(t),i=this.getKeyframeTrackValues(a,t,r);return new n.VectorKeyframeTrack(e+"."+o,a,i)}generateRotationTrack(e,t,r,o,a,i){void 0!==t.x&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(n.MathUtils.degToRad)),void 0!==t.y&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(n.MathUtils.degToRad)),void 0!==t.z&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(n.MathUtils.degToRad));const s=this.getTimesForAllAxes(t),l=this.getKeyframeTrackValues(s,t,r);void 0!==o&&((o=o.map(n.MathUtils.degToRad)).push(i),o=(new n.Euler).fromArray(o),o=(new n.Quaternion).setFromEuler(o)),void 0!==a&&((a=a.map(n.MathUtils.degToRad)).push(i),a=(new n.Euler).fromArray(a),a=(new n.Quaternion).setFromEuler(a).invert());const c=new n.Quaternion,u=new n.Euler,p=[];for(let n=0;n<l.length;n+=3)u.set(l[n],l[n+1],l[n+2],i),c.setFromEuler(u),void 0!==o&&c.premultiply(o),void 0!==a&&c.multiply(a),c.toArray(p,n/3*4);return new n.QuaternionKeyframeTrack(e+".quaternion",s,p)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,r=t.values.map((function(e){return e/100})),o=U.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new n.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+o+"]",t.times,r)}getTimesForAllAxes(e){let t=[];if(void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(e,t){return e-t})),t.length>1){let e=1,r=t[0];for(let n=1;n<t.length;n++){const o=t[n];o!==r&&(t[e]=o,r=o,e++)}t=t.slice(0,e)}return t}getKeyframeTrackValues(e,t,r){const n=r,o=[];let a=-1,i=-1,s=-1;return e.forEach((function(e){if(t.x&&(a=t.x.times.indexOf(e)),t.y&&(i=t.y.times.indexOf(e)),t.z&&(s=t.z.times.indexOf(e)),-1!==a){const e=t.x.values[a];o.push(e),n[0]=e}else o.push(n[0]);if(-1!==i){const e=t.y.values[i];o.push(e),n[1]=e}else o.push(n[1]);if(-1!==s){const e=t.z.values[s];o.push(e),n[2]=e}else o.push(n[2])})),o}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const r=e.values[t-1],n=e.values[t]-r,o=Math.abs(n);if(o>=180){const a=o/180,i=n/a;let s=r+i;const l=e.times[t-1],c=(e.times[t]-l)/a;let u=l+c;const p=[],d=[];for(;u<e.times[t];)p.push(u),u+=c,d.push(s),s+=i;e.times=ie(e.times,t,p),e.values=ie(e.values,t,d)}}}}class H{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new q,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,r=e.split(/[\r\n]+/);return r.forEach((function(e,n){const o=e.match(/^[\s\t]*;/),a=e.match(/^[\s\t]*$/);if(o||a)return;const i=e.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),s=e.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=e.match("^\\t{"+(t.currentIndent-1)+"}}");i?t.parseNodeBegin(e,i):s?t.parseNodeProperty(e,s,r[++n]):l?t.popStack():e.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(e)})),this.allNodes}parseNodeBegin(e,t){const r=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),o={name:r},a=this.parseNodeAttr(n),i=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(r,o):r in i?("PoseNode"===r?i.PoseNode.push(o):void 0!==i[r].id&&(i[r]={},i[r][i[r].id]=i[r]),""!==a.id&&(i[r][a.id]=o)):"number"===typeof a.id?(i[r]={},i[r][a.id]=o):"Properties70"!==r&&(i[r]="PoseNode"===r?[o]:o),"number"===typeof a.id&&(o.id=a.id),""!==a.name&&(o.attrName=a.name),""!==a.type&&(o.attrType=a.type),this.pushStack(o)}parseNodeAttr(e){let t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let r="",n="";return e.length>1&&(r=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:r,type:n}}parseNodeProperty(e,t,r){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),o=t[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===n&&","===o&&(o=r.replace(/"/g,"").replace(/,$/,"").trim());const a=this.getCurrentNode();if("Properties70"!==a.name){if("C"===n){const e=o.split(",").slice(1),t=parseInt(e[0]),r=parseInt(e[1]);let i=o.split(",").slice(3);i=i.map((function(e){return e.trim().replace(/^"/,"")})),n="connections",o=[t,r],function(e,t){for(let r=0,n=e.length,o=t.length;r<o;r++,n++)e[n]=t[r]}(o,i),void 0===a[n]&&(a[n]=[])}"Node"===n&&(a.id=o),n in a&&Array.isArray(a[n])?a[n].push(o):"a"!==n?a[n]=o:a.a=o,this.setCurrentProp(a,n),"a"===n&&","!==o.slice(-1)&&(a.a=oe(o))}else this.parseNodeSpecialProperty(e,n,o)}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=oe(t.a))}parseNodeSpecialProperty(e,t,r){const n=r.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),o=n[0],a=n[1],i=n[2],s=n[3];let l=n[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=oe(l)}this.getPrevNode()[o]={type:a,type2:i,flag:s,value:l},this.setCurrentProp(this.getPrevNode(),o)}}class Z{parse(e){const t=new K(e);t.skip(23);const r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);const n=new q;for(;!this.endOfContent(t);){const e=this.parseNode(t,r);null!==e&&n.add(e.name,e)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const r={},n=t>=7500?e.getUint64():e.getUint32(),o=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const a=e.getUint8(),i=e.getString(a);if(0===n)return null;const s=[];for(let p=0;p<o;p++)s.push(this.parseProperty(e));const l=s.length>0?s[0]:"",c=s.length>1?s[1]:"",u=s.length>2?s[2]:"";for(r.singleProperty=1===o&&e.getOffset()===n;n>e.getOffset();){const n=this.parseNode(e,t);null!==n&&this.parseSubNode(i,r,n)}return r.propertyList=s,"number"===typeof l&&(r.id=l),""!==c&&(r.attrName=c),""!==u&&(r.attrType=u),""!==i&&(r.name=i),r}parseSubNode(e,t,r){if(!0===r.singleProperty){const e=r.propertyList[0];Array.isArray(e)?(t[r.name]=r,r.a=e):t[r.name]=e}else if("Connections"===e&&"C"===r.name){const e=[];r.propertyList.forEach((function(t,r){0!==r&&e.push(t)})),void 0===t.connections&&(t.connections=[]),t.connections.push(e)}else if("Properties70"===r.name){Object.keys(r).forEach((function(e){t[e]=r[e]}))}else if("Properties70"===e&&"P"===r.name){let e=r.propertyList[0],n=r.propertyList[1];const o=r.propertyList[2],a=r.propertyList[3];let i;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===n.indexOf("Lcl ")&&(n=n.replace("Lcl ","Lcl_")),i="Color"===n||"ColorRGB"===n||"Vector"===n||"Vector3D"===n||0===n.indexOf("Lcl_")?[r.propertyList[4],r.propertyList[5],r.propertyList[6]]:r.propertyList[4],t[e]={type:n,type2:o,flag:a,value:i}}else void 0===t[r.name]?"number"===typeof r.id?(t[r.name]={},t[r.name][r.id]=r):t[r.name]=r:"PoseNode"===r.name?(Array.isArray(t[r.name])||(t[r.name]=[t[r.name]]),t[r.name].push(r)):void 0===t[r.name][r.id]&&(t[r.name][r.id]=r)}parseProperty(e){const t=e.getString(1);let r;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return r=e.getUint32(),e.getArrayBuffer(r);case"S":return r=e.getUint32(),e.getString(r);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),o=e.getUint32(),a=e.getUint32();if(0===o)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const i=D(new Uint8Array(e.getArrayBuffer(a))),s=new K(i.buffer);switch(t){case"b":case"c":return s.getBooleanArray(n);case"d":return s.getFloat64Array(n);case"f":return s.getFloat32Array(n);case"i":return s.getInt32Array(n);case"l":return s.getInt64Array(n)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class K{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1===(1&this.getUint8())}getBooleanArray(e){const t=[];for(let r=0;r<e;r++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,e=4294967295&~e,4294967295===e&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let r=0;r<e;r++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let n=0;n<e;n++)t[n]=this.getUint8();const r=t.indexOf(0);return r>=0&&(t=t.slice(0,r)),n.LoaderUtils.decodeText(new Uint8Array(t))}}class q{add(e,t){this[e]=t}}function Y(e){const t=e.match(/FBXVersion: (\d+)/);if(t){return parseInt(t[1])}throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function Q(e){return e/46186158e3}const $=[];function J(e,t,r,n){let o;switch(n.mappingType){case"ByPolygonVertex":o=e;break;case"ByPolygon":o=t;break;case"ByVertice":o=r;break;case"AllSame":o=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}"IndexToDirect"===n.referenceType&&(o=n.indices[o]);const a=o*n.dataSize,i=a+n.dataSize;return function(e,t,r,n){for(let o=r,a=0;o<n;o++,a++)e[a]=t[o];return e}($,n.buffer,a,i)}const ee=new n.Euler,te=new n.Vector3;function re(e){const t=new n.Matrix4,r=new n.Matrix4,o=new n.Matrix4,a=new n.Matrix4,i=new n.Matrix4,s=new n.Matrix4,l=new n.Matrix4,c=new n.Matrix4,u=new n.Matrix4,p=new n.Matrix4,d=new n.Matrix4,f=new n.Matrix4,h=e.inheritType?e.inheritType:0;if(e.translation&&t.setPosition(te.fromArray(e.translation)),e.preRotation){const t=e.preRotation.map(n.MathUtils.degToRad);t.push(e.eulerOrder),r.makeRotationFromEuler(ee.fromArray(t))}if(e.rotation){const t=e.rotation.map(n.MathUtils.degToRad);t.push(e.eulerOrder),o.makeRotationFromEuler(ee.fromArray(t))}if(e.postRotation){const t=e.postRotation.map(n.MathUtils.degToRad);t.push(e.eulerOrder),a.makeRotationFromEuler(ee.fromArray(t)),a.invert()}e.scale&&i.scale(te.fromArray(e.scale)),e.scalingOffset&&l.setPosition(te.fromArray(e.scalingOffset)),e.scalingPivot&&s.setPosition(te.fromArray(e.scalingPivot)),e.rotationOffset&&c.setPosition(te.fromArray(e.rotationOffset)),e.rotationPivot&&u.setPosition(te.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(d.copy(e.parentMatrix),p.copy(e.parentMatrixWorld));const m=r.clone().multiply(o).multiply(a),g=new n.Matrix4;g.extractRotation(p);const v=new n.Matrix4;v.copyPosition(p);const y=v.clone().invert().multiply(p),w=g.clone().invert().multiply(y),x=i,b=new n.Matrix4;if(0===h)b.copy(g).multiply(m).multiply(w).multiply(x);else if(1===h)b.copy(g).multiply(w).multiply(m).multiply(x);else{const e=(new n.Matrix4).scale((new n.Vector3).setFromMatrixScale(d)).clone().invert(),t=w.clone().multiply(e);b.copy(g).multiply(m).multiply(t).multiply(x)}const M=u.clone().invert(),I=s.clone().invert();let P=t.clone().multiply(c).multiply(u).multiply(r).multiply(o).multiply(a).multiply(M).multiply(l).multiply(s).multiply(i).multiply(I);const T=(new n.Matrix4).copyPosition(P),E=p.clone().multiply(T);return f.copyPosition(E),P=f.clone().multiply(b),P.premultiply(p.invert()),P}function ne(e){const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function oe(e){return e.split(",").map((function(e){return parseFloat(e)}))}function ae(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.byteLength),n.LoaderUtils.decodeText(new Uint8Array(e,t,r))}function ie(e,t,r){return e.slice(0,t).concat(r).concat(e.slice(t))}var se=r(9080);function le(e){return(0,se.F)(z,e)}le.preload=e=>se.F.preload(z,e),le.clear=e=>se.F.clear(z,e)},5964:(e,t,r)=>{"use strict";r.d(t,{H:()=>a});var n=r(7313),o=r(9080);function a(e,t){for(var r=arguments.length,a=new Array(r>2?r-2:0),i=2;i<r;i++)a[i-2]=arguments[i];const s=n.useRef(),l=(0,o.A)((e=>e.scene));return n.useLayoutEffect((()=>{let r;if(e&&null!=e&&e.current&&t&&(s.current=r=new t(e.current,...a)),r)return r.traverse((e=>e.raycast=()=>null)),l.add(r),()=>{s.current=void 0,l.remove(r),null==r.dispose||r.dispose()}}),[l,t,e,...a]),(0,o.C)((()=>{var e;null==(e=s.current)||null==e.update||e.update()})),s}},2362:(e,t,r)=>{"use strict";r.d(t,{i:()=>o});var n=r(5825);const o=(()=>parseInt(n.REVISION.replace(/\D+/g,"")))()},6790:(e,t,r)=>{"use strict";r.d(t,{V:()=>v});var n=r(7462),o=r(7313),a=r(1739),i=r(5825),s=r(9080);const l=new i.Vector3,c=new i.Vector3,u=new i.Vector3;function p(e,t,r){const n=l.setFromMatrixPosition(e.matrixWorld);n.project(t);const o=r.width/2,a=r.height/2;return[n.x*o+o,-n.y*a+a]}const d=e=>Math.abs(e)<1e-10?0:e;function f(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",n="matrix3d(";for(let o=0;16!==o;o++)n+=d(t[o]*e.elements[o])+(15!==o?",":")");return r+n}const h=(m=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>f(e,m));var m;const g=(e,t)=>{return f(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],"translate(-50%,-50%)");var r};const v=o.forwardRef(((e,t)=>{let{children:r,eps:f=.001,style:m,className:v,prepend:y,center:w,fullscreen:x,portal:b,distanceFactor:M,sprite:I=!1,transform:P=!1,occlude:T,onOcclude:E,castShadow:A,receiveShadow:k,material:F,geometry:S,zIndexRange:C=[16777271,0],calculatePosition:D=p,as:L="div",wrapperClass:N,pointerEvents:R="auto",...O}=e;const{gl:B,camera:j,scene:V,size:W,raycaster:U,events:z,viewport:G}=(0,s.A)(),[X]=o.useState((()=>document.createElement(L))),_=o.useRef(),H=o.useRef(null),Z=o.useRef(0),K=o.useRef([0,0]),q=o.useRef(null),Y=o.useRef(null),Q=(null==b?void 0:b.current)||z.connected||B.domElement.parentNode,$=o.useRef(null),J=o.useRef(!1),ee=o.useMemo((()=>T&&"blending"!==T||Array.isArray(T)&&T.length&&function(e){return e&&"object"===typeof e&&"current"in e}(T[0])),[T]);o.useLayoutEffect((()=>{const e=B.domElement;T&&"blending"===T?(e.style.zIndex="".concat(Math.floor(C[0]/2)),e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[T]),o.useLayoutEffect((()=>{if(H.current){const e=_.current=a.s(X);if(V.updateMatrixWorld(),P)X.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=D(H.current,j,W);X.style.cssText="position:absolute;top:0;left:0;transform:translate3d(".concat(e[0],"px,").concat(e[1],"px,0);transform-origin:0 0;")}return Q&&(y?Q.prepend(X):Q.appendChild(X)),()=>{Q&&Q.removeChild(X),e.unmount()}}}),[Q,P]),o.useLayoutEffect((()=>{N&&(X.className=N)}),[N]);const te=o.useMemo((()=>P?{position:"absolute",top:0,left:0,width:W.width,height:W.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:w?"translate3d(-50%,-50%,0)":"none",...x&&{top:-W.height/2,left:-W.width/2,width:W.width,height:W.height},...m}),[m,w,x,W,P]),re=o.useMemo((()=>({position:"absolute",pointerEvents:R})),[R]);o.useLayoutEffect((()=>{var e,n;(J.current=!1,P)?null==(e=_.current)||e.render(o.createElement("div",{ref:q,style:te},o.createElement("div",{ref:Y,style:re},o.createElement("div",{ref:t,className:v,style:m,children:r})))):null==(n=_.current)||n.render(o.createElement("div",{ref:t,style:te,className:v,children:r}))}));const ne=o.useRef(!0);(0,s.C)((e=>{if(H.current){j.updateMatrixWorld(),H.current.updateWorldMatrix(!0,!1);const e=P?K.current:D(H.current,j,W);if(P||Math.abs(Z.current-j.zoom)>f||Math.abs(K.current[0]-e[0])>f||Math.abs(K.current[1]-e[1])>f){const t=function(e,t){const r=l.setFromMatrixPosition(e.matrixWorld),n=c.setFromMatrixPosition(t.matrixWorld),o=r.sub(n),a=t.getWorldDirection(u);return o.angleTo(a)>Math.PI/2}(H.current,j);let r=!1;ee&&(Array.isArray(T)?r=T.map((e=>e.current)):"blending"!==T&&(r=[V]));const n=ne.current;if(r){const e=function(e,t,r,n){const o=l.setFromMatrixPosition(e.matrixWorld),a=o.clone();a.project(t),r.setFromCamera(a,t);const i=r.intersectObjects(n,!0);if(i.length){const e=i[0].distance;return o.distanceTo(r.ray.origin)<e}return!0}(H.current,j,U,r);ne.current=e&&!t}else ne.current=!t;n!==ne.current&&(E?E(!ne.current):X.style.display=ne.current?"block":"none");const o=Math.floor(C[0]/2),a=T?ee?[C[0],o]:[o-1,0]:C;if(X.style.zIndex="".concat(function(e,t,r){if(t instanceof i.PerspectiveCamera||t instanceof i.OrthographicCamera){const n=l.setFromMatrixPosition(e.matrixWorld),o=c.setFromMatrixPosition(t.matrixWorld),a=n.distanceTo(o),i=(r[1]-r[0])/(t.far-t.near),s=r[1]-i*t.far;return Math.round(i*a+s)}}(H.current,j,a)),P){const[e,t]=[W.width/2,W.height/2],r=j.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:o,left:a,bottom:i,right:s}=j,l=h(j.matrixWorldInverse),c=n?"scale(".concat(r,")translate(").concat(d(-(s+a)/2),"px,").concat(d((o+i)/2),"px)"):"translateZ(".concat(r,"px)");let u=H.current.matrixWorld;I&&(u=j.matrixWorldInverse.clone().transpose().copyPosition(u).scale(H.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),X.style.width=W.width+"px",X.style.height=W.height+"px",X.style.perspective=n?"":"".concat(r,"px"),q.current&&Y.current&&(q.current.style.transform="".concat(c).concat(l,"translate(").concat(e,"px,").concat(t,"px)"),Y.current.style.transform=g(u,1/((M||10)/400)))}else{const t=void 0===M?1:function(e,t){if(t instanceof i.OrthographicCamera)return t.zoom;if(t instanceof i.PerspectiveCamera){const r=l.setFromMatrixPosition(e.matrixWorld),n=c.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,a=r.distanceTo(n);return 1/(2*Math.tan(o/2)*a)}return 1}(H.current,j)*M;X.style.transform="translate3d(".concat(e[0],"px,").concat(e[1],"px,0) scale(").concat(t,")")}K.current=e,Z.current=j.zoom}}if(!ee&&$.current&&!J.current)if(P){if(q.current){const e=q.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=j;if(t||S)O.scale&&(Array.isArray(O.scale)?O.scale instanceof i.Vector3?$.current.scale.copy(O.scale.clone().divideScalar(1)):$.current.scale.set(1/O.scale[0],1/O.scale[1],1/O.scale[2]):$.current.scale.setScalar(1/O.scale));else{const t=(M||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;$.current.scale.set(r,n,1)}J.current=!0}}}else{const t=X.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/G.factor,r=t.clientWidth*e,n=t.clientHeight*e;$.current.scale.set(r,n,1),J.current=!0}$.current.lookAt(e.camera.position)}}));const oe=o.useMemo((()=>({vertexShader:P?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[P]);return o.createElement("group",(0,n.Z)({},O,{ref:H}),T&&!ee&&o.createElement("mesh",{castShadow:A,receiveShadow:k,ref:$},S||o.createElement("planeGeometry",null),F||o.createElement("shaderMaterial",{side:i.DoubleSide,vertexShader:oe.vertexShader,fragmentShader:oe.fragmentShader})))}))},9659:(e,t,r)=>{var n=9007199254740991,o="[object Arguments]",a="[object Function]",i="[object GeneratorFunction]",s="[object Symbol]",l="object"==typeof r.g&&r.g&&r.g.Object===Object&&r.g,c="object"==typeof self&&self&&self.Object===Object&&self,u=l||c||Function("return this")();function p(e,t){for(var r=-1,n=t.length,o=e.length;++r<n;)e[o+r]=t[r];return e}var d=Object.prototype,f=d.hasOwnProperty,h=d.toString,m=u.Symbol,g=d.propertyIsEnumerable,v=m?m.isConcatSpreadable:void 0,y=Math.max;function w(e,t,r,n,o){var a=-1,i=e.length;for(r||(r=x),o||(o=[]);++a<i;){var s=e[a];t>0&&r(s)?t>1?w(s,t-1,r,n,o):p(o,s):n||(o[o.length]=s)}return o}function x(e){return M(e)||function(e){return function(e){return I(e)&&function(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=n}(e.length)&&!function(e){var t=function(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}(e)?h.call(e):"";return t==a||t==i}(e)}(e)}(e)&&f.call(e,"callee")&&(!g.call(e,"callee")||h.call(e)==o)}(e)||!!(v&&e&&e[v])}function b(e){if("string"==typeof e||function(e){return"symbol"==typeof e||I(e)&&h.call(e)==s}(e))return e;var t=e+"";return"0"==t&&1/e==-Infinity?"-0":t}var M=Array.isArray;function I(e){return!!e&&"object"==typeof e}var P,T,E=(P=function(e,t){return null==e?{}:function(e,t){return function(e,t,r){for(var n=-1,o=t.length,a={};++n<o;){var i=t[n],s=e[i];r(s,i)&&(a[i]=s)}return a}(e=Object(e),t,(function(t,r){return r in e}))}(e,function(e,t){for(var r=-1,n=e?e.length:0,o=Array(n);++r<n;)o[r]=t(e[r],r,e);return o}(w(t,1),b))},T=y(void 0===T?P.length-1:T,0),function(){for(var e=arguments,t=-1,r=y(e.length-T,0),n=Array(r);++t<r;)n[t]=e[T+t];t=-1;for(var o=Array(T+1);++t<T;)o[t]=e[t];return o[T]=n,function(e,t,r){switch(r.length){case 0:return e.call(t);case 1:return e.call(t,r[0]);case 2:return e.call(t,r[0],r[1]);case 3:return e.call(t,r[0],r[1],r[2])}return e.apply(t,r)}(P,this,o)});e.exports=E}}]);