"use strict";(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[516,4600,6732],{4839:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(7462),a=n(7313),o=n(5825),i=n(676);const s=1e-5;const l=a.forwardRef((function(e,t){let{args:[n=1,l=1,c=1]=[],radius:u=.05,steps:d=1,smoothness:m=4,bevelSegments:f=4,creaseAngle:p=.4,children:v,...g}=e;const h=a.useMemo((()=>function(e,t,n){const r=new o.Shape,a=n-s;return r.absarc(s,s,s,-Math.PI/2,-Math.PI,!0),r.absarc(s,t-2*a,s,Math.PI,Math.PI/2,!0),r.absarc(e-2*a,t-2*a,s,Math.PI/2,0,!0),r.absarc(e-2*a,s,s,0,-Math.PI/2,!0),r}(n,l,u)),[n,l,u]),y=a.useMemo((()=>({depth:c-2*u,bevelEnabled:!0,bevelSegments:2*f,steps:d,bevelSize:u-s,bevelThickness:u,curveSegments:m})),[c,u,m]),w=a.useRef(null);return a.useLayoutEffect((()=>{w.current&&(w.current.center(),(0,i.LZ)(w.current,p))}),[h,y]),a.createElement("mesh",(0,r.Z)({ref:t},g),a.createElement("extrudeGeometry",{ref:w,args:[h,y]}),v)}))},3081:(e,t,n)=>{n.d(t,{P:()=>d});var r=n(7462),a=n(7313),o=n(5825),i=n(3002),s=n(4296),l=n(2362);class c extends o.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new o.Vector3(0,0,0)},lightColor:{value:new o.Color("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new o.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      ",fragmentShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <".concat(l.i>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n      ")})}}function u(e){let{opacity:t=1,radiusTop:n,radiusBottom:r,depthBuffer:s,color:l="white",distance:u=5,angle:d=.15,attenuation:m=5,anglePower:f=5}=e;const p=a.useRef(null),v=(0,i.A)((e=>e.size)),g=(0,i.A)((e=>e.camera)),h=(0,i.A)((e=>e.viewport.dpr)),[y]=a.useState((()=>new c)),[w]=a.useState((()=>new o.Vector3));n=void 0===n?.1:n,r=void 0===r?7*d:r,(0,i.C)((()=>{y.uniforms.spotPosition.value.copy(p.current.getWorldPosition(w)),p.current.lookAt(p.current.parent.target.getWorldPosition(w))}));const b=a.useMemo((()=>{const e=new o.CylinderGeometry(n,r,u,128,64,!0);return e.applyMatrix4((new o.Matrix4).makeTranslation(0,-u/2,0)),e.applyMatrix4((new o.Matrix4).makeRotationX(-Math.PI/2)),e}),[u,n,r]);return a.createElement(a.Fragment,null,a.createElement("mesh",{ref:p,geometry:b,raycast:()=>null},a.createElement("primitive",{object:y,attach:"material","uniforms-opacity-value":t,"uniforms-lightColor-value":l,"uniforms-attenuation-value":m,"uniforms-anglePower-value":f,"uniforms-depth-value":s,"uniforms-cameraNear-value":g.near,"uniforms-cameraFar-value":g.far,"uniforms-resolution-value":s?[v.width*h,v.height*h]:[0,0]})))}const d=a.forwardRef(((e,t)=>{let{opacity:n=1,radiusTop:o,radiusBottom:i,depthBuffer:l,color:c="white",distance:d=5,angle:m=.15,attenuation:f=5,anglePower:p=5,volumetric:v=!0,debug:g=!1,children:h,...y}=e;const w=a.useRef(null);return a.createElement("group",null,g&&w.current&&a.createElement("spotLightHelper",{args:[w.current]}),a.createElement("spotLight",(0,r.Z)({ref:(0,s.Z)([t,w]),angle:m,color:c,distance:d,castShadow:!0},y),v&&a.createElement(u,{debug:g,opacity:n,radiusTop:o,radiusBottom:i,depthBuffer:l,color:c,distance:d,angle:m,attenuation:f,anglePower:p})),h&&a.cloneElement(h,{spotlightRef:w,debug:g}))}))},2952:(e,t,n)=>{n.d(t,{Ab:()=>c,Cd:()=>s,FC:()=>g,FM:()=>v,JO:()=>d,KC:()=>m,N1:()=>y,Qq:()=>l,aL:()=>u,fg:()=>f,vO:()=>p,xu:()=>i,yI:()=>h});var r=n(7462),a=n(7313);function o(e,t){const n=e+"Geometry";return a.forwardRef(((e,o)=>{let{args:i,children:s,...l}=e;const c=a.useRef(null);return a.useImperativeHandle(o,(()=>c.current)),a.useLayoutEffect((()=>{null==t||t(c.current)})),a.createElement("mesh",(0,r.Z)({ref:c},l),a.createElement(n,{attach:"geometry",args:i}),s)}))}const i=o("box"),s=o("circle"),l=o("cone"),c=o("cylinder"),u=o("sphere"),d=o("plane"),m=o("torus"),f=o("torusKnot"),p=o("tetrahedron"),v=o("ring"),g=o("icosahedron"),h=o("octahedron"),y=o("dodecahedron")},5964:(e,t,n)=>{n.d(t,{H:()=>o});var r=n(7313),a=n(3002);function o(e,t){for(var n=arguments.length,o=new Array(n>2?n-2:0),i=2;i<n;i++)o[i-2]=arguments[i];const s=r.useRef(),l=(0,a.A)((e=>e.scene));return r.useLayoutEffect((()=>{let n;if(e&&null!=e&&e.current&&t&&(s.current=n=new t(e.current,...o)),n)return n.traverse((e=>e.raycast=()=>null)),l.add(n),()=>{s.current=void 0,l.remove(n),null==n.dispose||n.dispose()}}),[l,t,e,...o]),(0,a.C)((()=>{var e;null==(e=s.current)||null==e.update||e.update()})),s}},124:(e,t,n)=>{n.d(t,{K:()=>l});var r=n(7313),a=n(8640),o=n(1120);const i="https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/matcaps.json",s="https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d";function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024,n=arguments.length>2?arguments[2]:void 0;const l=(0,o.Rq)((()=>fetch(i).then((e=>e.json()))),["matcapList"]),c=l[0],u=r.useMemo((()=>Object.keys(l).length),[]),d=r.useMemo((()=>"string"===typeof e?e:"number"===typeof e?l[e]:null),[e]),m="".concat(d||c).concat(function(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}(t),".png"),f="".concat(s,"/").concat(t,"/").concat(m);return[(0,a.m)(f,n),f,u]}},54:(e,t,n)=>{n.d(t,{N:()=>c});var r=n(7313),a=n(8640),o=n(5825),i=n(1120);const s="https://rawcdn.githack.com/pmndrs/drei-assets/7a3104997e1576f83472829815b00880d88b32fb",l="https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/normals/normals.json";function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2?arguments[2]:void 0;const{repeat:c=[1,1],anisotropy:u=1,offset:d=[0,0]}=t,m=(0,i.Rq)((()=>fetch(l).then((e=>e.json()))),["normalsList"]),f=r.useMemo((()=>Object.keys(m).length),[]),p=m[0],v=m[e]||p,g="".concat(s,"/normals/").concat(v),h=(0,a.m)(g,n);return r.useLayoutEffect((()=>{h&&(h.wrapS=h.wrapT=o.RepeatWrapping,h.repeat=new o.Vector2(c[0],c[1]),h.offset=new o.Vector2(d[0],d[1]),h.anisotropy=u)}),[h,u,c,d]),[h,g,f]}},8640:(e,t,n)=>{n.d(t,{m:()=>s});var r=n(5825),a=n(3002),o=n(7313);const i=e=>e===Object(e)&&!Array.isArray(e)&&"function"!==typeof e;function s(e,t){const n=(0,a.A)((e=>e.gl)),s=(0,a.F)(r.TextureLoader,i(e)?Object.values(e):e);if((0,o.useLayoutEffect)((()=>{null==t||t(s)}),[t]),(0,o.useEffect)((()=>{if("initTexture"in n){(Array.isArray(s)?s:[s]).forEach(n.initTexture)}}),[n,s]),i(e)){const t={};let n=0;for(const r in e)t[r]=s[n++];return t}return s}s.preload=e=>a.F.preload(r.TextureLoader,e),s.clear=e=>a.F.clear(r.TextureLoader,e)},2362:(e,t,n)=>{n.d(t,{i:()=>a});var r=n(5825);const a=(()=>parseInt(r.REVISION.replace(/\D+/g,"")))()}}]);