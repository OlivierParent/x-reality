"use strict";(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[6662],{3280:(e,t,n)=>{n.d(t,{p:()=>s});var r=n(4704),o=n(5397),a=n(9817);let i;var l;function s(){const{gravity:e,paused:t,showDebug:n}=(0,r.M4)(o.O.SCHEMA.PHYSICS,{gravity:i.gravity(),paused:i.paused(),showDebug:i.showDebug(!0)},a.F.folder(o.O.ORDER.PHYSICS));return{gravity:e,paused:t,showDebug:n}}(l=i||(i={})).gravity=function(){return{label:"Gravity",hint:"Default = 9.81",value:{x:arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y:arguments.length>1&&void 0!==arguments[1]?arguments[1]:-9.80665,z:arguments.length>2&&void 0!==arguments[2]?arguments[2]:0}}},l.paused=function(){return{label:"Paused",hint:"Pause physics simulation.",value:arguments.length>0&&void 0!==arguments[0]&&arguments[0]}},l.showDebug=function(){return{label:"Debug",hint:"Show debug geometry.",value:arguments.length>0&&void 0!==arguments[0]&&arguments[0]}}},1533:(e,t,n)=>{n.d(t,{A:()=>p});var r=n(259),o=n(7066),a=n(5819),i=n(3082),l=n(4704),s=n(7313),c=n(1724),u=n(7862),d=n(4662),m=n(3280),f=n(6417);const p=e=>{let{children:t}=e;const n=(0,d.p)(),p=(0,m.p)();return(0,f.jsxs)(f.Fragment,{children:[(0,f.jsx)(a.Xz,{camera:void 0,flat:n.flat,frameloop:n.frameloop,linear:n.linear,orthographic:!1,shadows:n.shadows,children:(0,f.jsxs)(s.Suspense,{children:[(0,f.jsx)(c.Z,{}),(0,f.jsx)(u.u,{}),(0,f.jsx)(r.z,{enableDamping:!0,enablePan:!0,enableZoom:!0}),(0,f.jsx)(i.wI,{colliders:void 0,debug:p.showDebug,gravity:[p.gravity.x,p.gravity.y,p.gravity.z],paused:p.paused,timeStep:"vary",updatePriority:void 0,children:t})]})}),(0,f.jsx)(l.Zf,{collapsed:!1,fill:!1,flat:!1,hidden:!1,oneLineLabels:!0,titleBar:!0}),(0,f.jsx)(o.a,{})]})}},1968:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});var r=n(6790),o=n(3082),a=n(5867),i=n(6417);const l=.25,s=[{collider:(0,i.jsx)(o.dp,{args:[l]}),name:"ball"},{collider:(0,i.jsx)(o.zm,{args:[l,l]}),name:"capsule"},{collider:(0,i.jsx)(o.aF,{args:[l,l]}),name:"cone"},{collider:(0,i.jsx)(o.jc,{args:[l,l,l]}),name:"cuboid"},{collider:(0,i.jsx)(o.Y_,{args:[l,l]}),name:"cylinder"},{collider:(0,i.jsx)(o.x1,{args:[l,l,l,.025]}),name:"round cuboid"}],c=e=>(0,i.jsx)("group",{name:"Rapier Manual Colliders",...e,children:s.map(((e,t)=>{let{collider:n,name:l}=e;return(0,i.jsxs)(o.ib,{colliders:!1,position:[1*(t-(s.length-1)/2),0,0],type:"fixed",children:[n,(0,i.jsx)(r.V,{className:a.Z.label,position:[0,-.5,0],children:l})]},"manual-collider-".concat(t))}))});var u=n(1533);const d=e=>(0,i.jsx)(u.A,{children:(0,i.jsx)(c,{...e})})},3081:(e,t,n)=>{n.d(t,{P:()=>d});var r=n(7462),o=n(7313),a=n(5825),i=n(6351),l=n(4296),s=n(2362);class c extends a.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new a.Vector3(0,0,0)},lightColor:{value:new a.Color("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new a.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      ",fragmentShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <".concat(s.i>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n      ")})}}function u(e){let{opacity:t=1,radiusTop:n,radiusBottom:r,depthBuffer:l,color:s="white",distance:u=5,angle:d=.15,attenuation:m=5,anglePower:f=5}=e;const p=o.useRef(null),h=(0,i.A)((e=>e.size)),v=(0,i.A)((e=>e.camera)),g=(0,i.A)((e=>e.viewport.dpr)),[y]=o.useState((()=>new c)),[x]=o.useState((()=>new a.Vector3));n=void 0===n?.1:n,r=void 0===r?7*d:r,(0,i.C)((()=>{y.uniforms.spotPosition.value.copy(p.current.getWorldPosition(x)),p.current.lookAt(p.current.parent.target.getWorldPosition(x))}));const w=o.useMemo((()=>{const e=new a.CylinderGeometry(n,r,u,128,64,!0);return e.applyMatrix4((new a.Matrix4).makeTranslation(0,-u/2,0)),e.applyMatrix4((new a.Matrix4).makeRotationX(-Math.PI/2)),e}),[u,n,r]);return o.createElement(o.Fragment,null,o.createElement("mesh",{ref:p,geometry:w,raycast:()=>null},o.createElement("primitive",{object:y,attach:"material","uniforms-opacity-value":t,"uniforms-lightColor-value":s,"uniforms-attenuation-value":m,"uniforms-anglePower-value":f,"uniforms-depth-value":l,"uniforms-cameraNear-value":v.near,"uniforms-cameraFar-value":v.far,"uniforms-resolution-value":l?[h.width*g,h.height*g]:[0,0]})))}const d=o.forwardRef(((e,t)=>{let{opacity:n=1,radiusTop:a,radiusBottom:i,depthBuffer:s,color:c="white",distance:d=5,angle:m=.15,attenuation:f=5,anglePower:p=5,volumetric:h=!0,debug:v=!1,children:g,...y}=e;const x=o.useRef(null);return o.createElement("group",null,v&&x.current&&o.createElement("spotLightHelper",{args:[x.current]}),o.createElement("spotLight",(0,r.Z)({ref:(0,l.Z)([t,x]),angle:m,color:c,distance:d,castShadow:!0},y),h&&o.createElement(u,{debug:v,opacity:n,radiusTop:a,radiusBottom:i,depthBuffer:s,color:c,distance:d,angle:m,attenuation:f,anglePower:p})),g&&o.cloneElement(g,{spotlightRef:x,debug:v}))}))},5964:(e,t,n)=>{n.d(t,{H:()=>a});var r=n(7313),o=n(6351);function a(e,t){for(var n=arguments.length,a=new Array(n>2?n-2:0),i=2;i<n;i++)a[i-2]=arguments[i];const l=r.useRef(),s=(0,o.A)((e=>e.scene));return r.useLayoutEffect((()=>{let n;if(e&&null!=e&&e.current&&t&&(l.current=n=new t(e.current,...a)),n)return n.traverse((e=>e.raycast=()=>null)),s.add(n),()=>{l.current=void 0,s.remove(n),null==n.dispose||n.dispose()}}),[s,t,e,...a]),(0,o.C)((()=>{var e;null==(e=l.current)||null==e.update||e.update()})),l}},2362:(e,t,n)=>{n.d(t,{i:()=>o});var r=n(5825);const o=(()=>parseInt(r.REVISION.replace(/\D+/g,"")))()},6790:(e,t,n)=>{n.d(t,{V:()=>g});var r=n(7462),o=n(7313),a=n(1739),i=n(5825),l=n(6351);const s=new i.Vector3,c=new i.Vector3,u=new i.Vector3;function d(e,t,n){const r=s.setFromMatrixPosition(e.matrixWorld);r.project(t);const o=n.width/2,a=n.height/2;return[r.x*o+o,-r.y*a+a]}const m=e=>Math.abs(e)<1e-10?0:e;function f(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r="matrix3d(";for(let o=0;16!==o;o++)r+=m(t[o]*e.elements[o])+(15!==o?",":")");return n+r}const p=(h=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>f(e,h));var h;const v=(e,t)=>{return f(e,[1/(n=t),1/n,1/n,1,-1/n,-1/n,-1/n,-1,1/n,1/n,1/n,1,1,1,1,1],"translate(-50%,-50%)");var n};const g=o.forwardRef(((e,t)=>{let{children:n,eps:f=.001,style:h,className:g,prepend:y,center:x,fullscreen:w,portal:b,distanceFactor:P,sprite:M=!1,transform:S=!1,occlude:E,onOcclude:C,castShadow:j,receiveShadow:z,material:F,geometry:W,zIndexRange:R=[16777271,0],calculatePosition:I=d,as:_="div",wrapperClass:D,pointerEvents:Z="auto",...N}=e;const{gl:A,camera:V,scene:T,size:k,raycaster:H,events:O,viewport:L}=(0,l.A)(),[B]=o.useState((()=>document.createElement(_))),G=o.useRef(),Y=o.useRef(null),U=o.useRef(0),X=o.useRef([0,0]),K=o.useRef(null),q=o.useRef(null),J=(null==b?void 0:b.current)||O.connected||A.domElement.parentNode,Q=o.useRef(null),$=o.useRef(!1),ee=o.useMemo((()=>E&&"blending"!==E||Array.isArray(E)&&E.length&&function(e){return e&&"object"===typeof e&&"current"in e}(E[0])),[E]);o.useLayoutEffect((()=>{const e=A.domElement;E&&"blending"===E?(e.style.zIndex="".concat(Math.floor(R[0]/2)),e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[E]),o.useLayoutEffect((()=>{if(Y.current){const e=G.current=a.s(B);if(T.updateMatrixWorld(),S)B.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=I(Y.current,V,k);B.style.cssText="position:absolute;top:0;left:0;transform:translate3d(".concat(e[0],"px,").concat(e[1],"px,0);transform-origin:0 0;")}return J&&(y?J.prepend(B):J.appendChild(B)),()=>{J&&J.removeChild(B),e.unmount()}}}),[J,S]),o.useLayoutEffect((()=>{D&&(B.className=D)}),[D]);const te=o.useMemo((()=>S?{position:"absolute",top:0,left:0,width:k.width,height:k.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:x?"translate3d(-50%,-50%,0)":"none",...w&&{top:-k.height/2,left:-k.width/2,width:k.width,height:k.height},...h}),[h,x,w,k,S]),ne=o.useMemo((()=>({position:"absolute",pointerEvents:Z})),[Z]);o.useLayoutEffect((()=>{var e,r;($.current=!1,S)?null==(e=G.current)||e.render(o.createElement("div",{ref:K,style:te},o.createElement("div",{ref:q,style:ne},o.createElement("div",{ref:t,className:g,style:h,children:n})))):null==(r=G.current)||r.render(o.createElement("div",{ref:t,style:te,className:g,children:n}))}));const re=o.useRef(!0);(0,l.C)((e=>{if(Y.current){V.updateMatrixWorld(),Y.current.updateWorldMatrix(!0,!1);const e=S?X.current:I(Y.current,V,k);if(S||Math.abs(U.current-V.zoom)>f||Math.abs(X.current[0]-e[0])>f||Math.abs(X.current[1]-e[1])>f){const t=function(e,t){const n=s.setFromMatrixPosition(e.matrixWorld),r=c.setFromMatrixPosition(t.matrixWorld),o=n.sub(r),a=t.getWorldDirection(u);return o.angleTo(a)>Math.PI/2}(Y.current,V);let n=!1;ee&&(Array.isArray(E)?n=E.map((e=>e.current)):"blending"!==E&&(n=[T]));const r=re.current;if(n){const e=function(e,t,n,r){const o=s.setFromMatrixPosition(e.matrixWorld),a=o.clone();a.project(t),n.setFromCamera(a,t);const i=n.intersectObjects(r,!0);if(i.length){const e=i[0].distance;return o.distanceTo(n.ray.origin)<e}return!0}(Y.current,V,H,n);re.current=e&&!t}else re.current=!t;r!==re.current&&(C?C(!re.current):B.style.display=re.current?"block":"none");const o=Math.floor(R[0]/2),a=E?ee?[R[0],o]:[o-1,0]:R;if(B.style.zIndex="".concat(function(e,t,n){if(t instanceof i.PerspectiveCamera||t instanceof i.OrthographicCamera){const r=s.setFromMatrixPosition(e.matrixWorld),o=c.setFromMatrixPosition(t.matrixWorld),a=r.distanceTo(o),i=(n[1]-n[0])/(t.far-t.near),l=n[1]-i*t.far;return Math.round(i*a+l)}}(Y.current,V,a)),S){const[e,t]=[k.width/2,k.height/2],n=V.projectionMatrix.elements[5]*t,{isOrthographicCamera:r,top:o,left:a,bottom:i,right:l}=V,s=p(V.matrixWorldInverse),c=r?"scale(".concat(n,")translate(").concat(m(-(l+a)/2),"px,").concat(m((o+i)/2),"px)"):"translateZ(".concat(n,"px)");let u=Y.current.matrixWorld;M&&(u=V.matrixWorldInverse.clone().transpose().copyPosition(u).scale(Y.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),B.style.width=k.width+"px",B.style.height=k.height+"px",B.style.perspective=r?"":"".concat(n,"px"),K.current&&q.current&&(K.current.style.transform="".concat(c).concat(s,"translate(").concat(e,"px,").concat(t,"px)"),q.current.style.transform=v(u,1/((P||10)/400)))}else{const t=void 0===P?1:function(e,t){if(t instanceof i.OrthographicCamera)return t.zoom;if(t instanceof i.PerspectiveCamera){const n=s.setFromMatrixPosition(e.matrixWorld),r=c.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,a=n.distanceTo(r);return 1/(2*Math.tan(o/2)*a)}return 1}(Y.current,V)*P;B.style.transform="translate3d(".concat(e[0],"px,").concat(e[1],"px,0) scale(").concat(t,")")}X.current=e,U.current=V.zoom}}if(!ee&&Q.current&&!$.current)if(S){if(K.current){const e=K.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=V;if(t||W)N.scale&&(Array.isArray(N.scale)?N.scale instanceof i.Vector3?Q.current.scale.copy(N.scale.clone().divideScalar(1)):Q.current.scale.set(1/N.scale[0],1/N.scale[1],1/N.scale[2]):Q.current.scale.setScalar(1/N.scale));else{const t=(P||10)/400,n=e.clientWidth*t,r=e.clientHeight*t;Q.current.scale.set(n,r,1)}$.current=!0}}}else{const t=B.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/L.factor,n=t.clientWidth*e,r=t.clientHeight*e;Q.current.scale.set(n,r,1),$.current=!0}Q.current.lookAt(e.camera.position)}}));const oe=o.useMemo((()=>({vertexShader:S?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom" \n            is false. \n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n            \n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[S]);return o.createElement("group",(0,r.Z)({},N,{ref:Y}),E&&!ee&&o.createElement("mesh",{castShadow:j,receiveShadow:z,ref:Q},W||o.createElement("planeGeometry",null),F||o.createElement("shaderMaterial",{side:i.DoubleSide,vertexShader:oe.vertexShader,fragmentShader:oe.fragmentShader})))}))},5867:(e,t,n)=>{n.d(t,{Z:()=>r});const r={label:"labels_label__7DKCB"}}}]);