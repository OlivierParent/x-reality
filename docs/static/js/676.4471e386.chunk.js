"use strict";(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[676],{676:(t,e,r)=>{r.d(e,{$1:()=>n,LZ:()=>i,Vs:()=>s});var o=r(5825);function n(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-4;e=Math.max(e,Number.EPSILON);const r={},n=t.getIndex(),s=t.getAttribute("position"),i=n?n.count:s.count;let u=0;const c=Object.keys(t.attributes),l={},f={},a=[],g=["getX","getY","getZ","getW"];for(let o=0,p=c.length;o<p;o++){const e=c[o];l[e]=[];const r=t.morphAttributes[e];r&&(f[e]=new Array(r.length).fill(0).map((()=>[])))}const h=Math.log10(1/e),b=Math.pow(10,h);for(let o=0;o<i;o++){const e=n?n.getX(o):o;let s="";for(let r=0,o=c.length;r<o;r++){const o=c[r],n=t.getAttribute(o),i=n.itemSize;for(let t=0;t<i;t++)s+="".concat(~~(n[g[t]](e)*b),",")}if(s in r)a.push(r[s]);else{for(let r=0,o=c.length;r<o;r++){const o=c[r],n=t.getAttribute(o),s=t.morphAttributes[o],i=n.itemSize,u=l[o],a=f[o];for(let t=0;t<i;t++){const r=g[t];if(u.push(n[r](e)),s)for(let t=0,o=s.length;t<o;t++)a[t].push(s[t][r](e))}}r[s]=u,a.push(u),u++}}const d=t.clone();for(let p=0,m=c.length;p<m;p++){const e=c[p],r=t.getAttribute(e),n=new r.array.constructor(l[e]),s=new o.BufferAttribute(n,r.itemSize,r.normalized);if(d.setAttribute(e,s),e in f)for(let i=0;i<f[e].length;i++){const r=t.morphAttributes[e][i],n=new r.array.constructor(f[e][i]),s=new o.BufferAttribute(n,r.itemSize,r.normalized);d.morphAttributes[e][i]=s}}return d.setIndex(a),d}function s(t,e){if(e===o.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===o.TriangleFanDrawMode||e===o.TriangleStripDrawMode){let r=t.getIndex();if(null===r){const e=[],o=t.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<o.count;t++)e.push(t);t.setIndex(e),r=t.getIndex()}const n=r.count-2,s=[];if(r)if(e===o.TriangleFanDrawMode)for(let t=1;t<=n;t++)s.push(r.getX(0)),s.push(r.getX(t)),s.push(r.getX(t+1));else for(let t=0;t<n;t++)t%2===0?(s.push(r.getX(t)),s.push(r.getX(t+1)),s.push(r.getX(t+2))):(s.push(r.getX(t+2)),s.push(r.getX(t+1)),s.push(r.getX(t)));s.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=t.clone();return i.setIndex(s),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}function i(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Math.PI/3;const r=Math.cos(e),n=100*(1+1e-10),s=[new o.Vector3,new o.Vector3,new o.Vector3],i=new o.Vector3,u=new o.Vector3,c=new o.Vector3,l=new o.Vector3;function f(t){const e=~~(t.x*n),r=~~(t.y*n),o=~~(t.z*n);return"".concat(e,",").concat(r,",").concat(o)}const a=t.index?t.toNonIndexed():t,g=a.attributes.position,h={};for(let p=0,m=g.count/3;p<m;p++){const t=3*p,e=s[0].fromBufferAttribute(g,t+0),r=s[1].fromBufferAttribute(g,t+1),n=s[2].fromBufferAttribute(g,t+2);i.subVectors(n,r),u.subVectors(e,r);const c=(new o.Vector3).crossVectors(i,u).normalize();for(let o=0;o<3;o++){const t=f(s[o]);t in h||(h[t]=[]),h[t].push(c)}}const b=new Float32Array(3*g.count),d=new o.BufferAttribute(b,3,!1);for(let o=0,p=g.count/3;o<p;o++){const t=3*o,e=s[0].fromBufferAttribute(g,t+0),n=s[1].fromBufferAttribute(g,t+1),a=s[2].fromBufferAttribute(g,t+2);i.subVectors(a,n),u.subVectors(e,n),c.crossVectors(i,u).normalize();for(let o=0;o<3;o++){const e=h[f(s[o])];l.set(0,0,0);for(let t=0,o=e.length;t<o;t++){const o=e[t];c.dot(o)>r&&l.add(o)}l.normalize(),d.setXYZ(t+o,l.x,l.y,l.z)}}return a.setAttribute("normal",d),a}}}]);