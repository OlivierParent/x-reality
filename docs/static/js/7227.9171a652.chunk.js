"use strict";(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[7227],{7227:(e,t,r)=>{r.d(t,{Q:()=>d});var n=r(7462),i=r(7313),a=r(5825),o=r(3002),l=r(4296),s=r(2362);class u extends a.ShaderMaterial{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new a.Vector2;super({uniforms:{inputBuffer:new a.Uniform(null),depthBuffer:new a.Uniform(null),resolution:new a.Uniform(new a.Vector2),texelSize:new a.Uniform(new a.Vector2),halfTexelSize:new a.Uniform(new a.Vector2),kernel:new a.Uniform(0),scale:new a.Uniform(1),cameraNear:new a.Uniform(0),cameraFar:new a.Uniform(1),minDepthThreshold:new a.Uniform(0),maxDepthThreshold:new a.Uniform(1),depthScale:new a.Uniform(0),depthToBlurRatioBias:new a.Uniform(.25)},fragmentShader:"#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <".concat(s.i>=154?"colorspace_fragment":"encodings_fragment",">\n        }"),vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:a.NoBlending,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class h{constructor(e){let{gl:t,resolution:r,width:n=500,height:i=500,minDepthThreshold:o=0,maxDepthThreshold:l=1,depthScale:s=0,depthToBlurRatioBias:h=.25}=e;this.renderToScreen=!1,this.renderTargetA=new a.WebGLRenderTarget(r,r,{minFilter:a.LinearFilter,magFilter:a.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:a.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new u,this.convolutionMaterial.setTexelSize(1/n,1/i),this.convolutionMaterial.setResolution(new a.Vector2(n,i)),this.scene=new a.Scene,this.camera=new a.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=o,this.convolutionMaterial.uniforms.maxDepthThreshold.value=l,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=h,this.convolutionMaterial.defines.USE_DEPTH=s>0;const m=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),d=new Float32Array([0,0,2,0,0,2]),f=new a.BufferGeometry;f.setAttribute("position",new a.BufferAttribute(m,3)),f.setAttribute("uv",new a.BufferAttribute(d,2)),this.screen=new a.Mesh(f,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const n=this.scene,i=this.camera,a=this.renderTargetA,o=this.renderTargetB;let l=this.convolutionMaterial,s=l.uniforms;s.depthBuffer.value=t.depthTexture;const u=l.kernel;let h,m,d,f=t;for(m=0,d=u.length-1;m<d;++m)h=0===(1&m)?a:o,s.kernel.value=u[m],s.inputBuffer.value=f.texture,e.setRenderTarget(h),e.render(n,i),f=h;s.kernel.value=u[m],s.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(n,i)}}class m extends a.MeshStandardMaterial{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader="\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ".concat(e.vertexShader),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader="\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ".concat(e.fragmentShader),e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}const d=i.forwardRef(((e,t)=>{let{mixBlur:r=0,mixStrength:s=1,resolution:u=256,blur:d=[0,0],minDepthThreshold:f=.9,maxDepthThreshold:v=1,depthScale:c=0,depthToBlurRatioBias:p=.25,mirror:x=0,distortion:g=1,mixContrast:_=1,distortionMap:D,reflectorOffset:T=0,...S}=e;(0,o.e)({MeshReflectorMaterialImpl:m});const B=(0,o.A)((e=>{let{gl:t}=e;return t})),U=(0,o.A)((e=>{let{camera:t}=e;return t})),M=(0,o.A)((e=>{let{scene:t}=e;return t}));d=Array.isArray(d)?d:[d,d];const w=d[0]+d[1]>0,y=i.useRef(null),[F]=i.useState((()=>new a.Plane)),[b]=i.useState((()=>new a.Vector3)),[R]=i.useState((()=>new a.Vector3)),[C]=i.useState((()=>new a.Vector3)),[E]=i.useState((()=>new a.Matrix4)),[A]=i.useState((()=>new a.Vector3(0,0,-1))),[V]=i.useState((()=>new a.Vector4)),[z]=i.useState((()=>new a.Vector3)),[P]=i.useState((()=>new a.Vector3)),[k]=i.useState((()=>new a.Vector4)),[L]=i.useState((()=>new a.Matrix4)),[W]=i.useState((()=>new a.PerspectiveCamera)),j=i.useCallback((()=>{var e;const t=y.current.parent||(null==(e=y.current)?void 0:e.__r3f.parent);if(!t)return;if(R.setFromMatrixPosition(t.matrixWorld),C.setFromMatrixPosition(U.matrixWorld),E.extractRotation(t.matrixWorld),b.set(0,0,1),b.applyMatrix4(E),R.addScaledVector(b,T),z.subVectors(R,C),z.dot(b)>0)return;z.reflect(b).negate(),z.add(R),E.extractRotation(U.matrixWorld),A.set(0,0,-1),A.applyMatrix4(E),A.add(C),P.subVectors(R,A),P.reflect(b).negate(),P.add(R),W.position.copy(z),W.up.set(0,1,0),W.up.applyMatrix4(E),W.up.reflect(b),W.lookAt(P),W.far=U.far,W.updateMatrixWorld(),W.projectionMatrix.copy(U.projectionMatrix),L.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),L.multiply(W.projectionMatrix),L.multiply(W.matrixWorldInverse),L.multiply(t.matrixWorld),F.setFromNormalAndCoplanarPoint(b,R),F.applyMatrix4(W.matrixWorldInverse),V.set(F.normal.x,F.normal.y,F.normal.z,F.constant);const r=W.projectionMatrix;k.x=(Math.sign(V.x)+r.elements[8])/r.elements[0],k.y=(Math.sign(V.y)+r.elements[9])/r.elements[5],k.z=-1,k.w=(1+r.elements[10])/r.elements[14],V.multiplyScalar(2/V.dot(k)),r.elements[2]=V.x,r.elements[6]=V.y,r.elements[10]=V.z+1,r.elements[14]=V.w}),[U,T]),[I,N,O,H]=i.useMemo((()=>{const e={minFilter:a.LinearFilter,magFilter:a.LinearFilter,type:a.HalfFloatType},t=new a.WebGLRenderTarget(u,u,e);t.depthBuffer=!0,t.depthTexture=new a.DepthTexture(u,u),t.depthTexture.format=a.DepthFormat,t.depthTexture.type=a.UnsignedShortType;const n=new a.WebGLRenderTarget(u,u,e);return[t,n,new h({gl:B,resolution:u,width:d[0],height:d[1],minDepthThreshold:f,maxDepthThreshold:v,depthScale:c,depthToBlurRatioBias:p}),{mirror:x,textureMatrix:L,mixBlur:r,tDiffuse:t.texture,tDepth:t.depthTexture,tDiffuseBlur:n.texture,hasBlur:w,mixStrength:s,minDepthThreshold:f,maxDepthThreshold:v,depthScale:c,depthToBlurRatioBias:p,distortion:g,distortionMap:D,mixContrast:_,"defines-USE_BLUR":w?"":void 0,"defines-USE_DEPTH":c>0?"":void 0,"defines-USE_DISTORTION":D?"":void 0}]}),[B,d,L,u,x,w,r,s,f,v,c,p,g,D,_]);return(0,o.C)((()=>{var e;const t=y.current.parent||(null==(e=y.current)?void 0:e.__r3f.parent);if(!t)return;t.visible=!1;const r=B.xr.enabled,n=B.shadowMap.autoUpdate;j(),B.xr.enabled=!1,B.shadowMap.autoUpdate=!1,B.setRenderTarget(I),B.state.buffers.depth.setMask(!0),B.autoClear||B.clear(),B.render(M,W),w&&O.render(B,I,N),B.xr.enabled=r,B.shadowMap.autoUpdate=n,t.visible=!0,B.setRenderTarget(null)})),i.createElement("meshReflectorMaterialImpl",(0,n.Z)({attach:"material",key:"key"+H["defines-USE_BLUR"]+H["defines-USE_DEPTH"]+H["defines-USE_DISTORTION"],ref:(0,l.Z)([y,t])},H,S))}))}}]);