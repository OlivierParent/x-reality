"use strict";(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[8751],{7227:(e,t,r)=>{r.d(t,{Q:()=>m});var n=r(7462),i=r(7313),o=r(5825),a=r(3002),s=r(4296),l=r(2362);class u extends o.ShaderMaterial{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new o.Vector2;super({uniforms:{inputBuffer:new o.Uniform(null),depthBuffer:new o.Uniform(null),resolution:new o.Uniform(new o.Vector2),texelSize:new o.Uniform(new o.Vector2),halfTexelSize:new o.Uniform(new o.Vector2),kernel:new o.Uniform(0),scale:new o.Uniform(1),cameraNear:new o.Uniform(0),cameraFar:new o.Uniform(1),minDepthThreshold:new o.Uniform(0),maxDepthThreshold:new o.Uniform(1),depthScale:new o.Uniform(0),depthToBlurRatioBias:new o.Uniform(.25)},fragmentShader:"#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <".concat(l.i>=154?"colorspace_fragment":"encodings_fragment",">\n        }"),vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:o.NoBlending,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class h{constructor(e){let{gl:t,resolution:r,width:n=500,height:i=500,minDepthThreshold:a=0,maxDepthThreshold:s=1,depthScale:l=0,depthToBlurRatioBias:h=.25}=e;this.renderToScreen=!1,this.renderTargetA=new o.WebGLRenderTarget(r,r,{minFilter:o.LinearFilter,magFilter:o.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:o.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new u,this.convolutionMaterial.setTexelSize(1/n,1/i),this.convolutionMaterial.setResolution(new o.Vector2(n,i)),this.scene=new o.Scene,this.camera=new o.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=s,this.convolutionMaterial.uniforms.depthScale.value=l,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=h,this.convolutionMaterial.defines.USE_DEPTH=l>0;const d=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),m=new Float32Array([0,0,2,0,0,2]),f=new o.BufferGeometry;f.setAttribute("position",new o.BufferAttribute(d,3)),f.setAttribute("uv",new o.BufferAttribute(m,2)),this.screen=new o.Mesh(f,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const n=this.scene,i=this.camera,o=this.renderTargetA,a=this.renderTargetB;let s=this.convolutionMaterial,l=s.uniforms;l.depthBuffer.value=t.depthTexture;const u=s.kernel;let h,d,m,f=t;for(d=0,m=u.length-1;d<m;++d)h=0===(1&d)?o:a,l.kernel.value=u[d],l.inputBuffer.value=f.texture,e.setRenderTarget(h),e.render(n,i),f=h;l.kernel.value=u[d],l.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(n,i)}}class d extends o.MeshStandardMaterial{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader="\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ".concat(e.vertexShader),e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader="\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ".concat(e.fragmentShader),e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}const m=i.forwardRef(((e,t)=>{let{mixBlur:r=0,mixStrength:l=1,resolution:u=256,blur:m=[0,0],minDepthThreshold:f=.9,maxDepthThreshold:c=1,depthScale:v=0,depthToBlurRatioBias:p=.25,mirror:x=0,distortion:g=1,mixContrast:_=1,distortionMap:T,reflectorOffset:S=0,...D}=e;(0,a.e)({MeshReflectorMaterialImpl:d});const B=(0,a.A)((e=>{let{gl:t}=e;return t})),U=(0,a.A)((e=>{let{camera:t}=e;return t})),y=(0,a.A)((e=>{let{scene:t}=e;return t}));m=Array.isArray(m)?m:[m,m];const w=m[0]+m[1]>0,M=i.useRef(null),[F]=i.useState((()=>new o.Plane)),[b]=i.useState((()=>new o.Vector3)),[R]=i.useState((()=>new o.Vector3)),[C]=i.useState((()=>new o.Vector3)),[E]=i.useState((()=>new o.Matrix4)),[A]=i.useState((()=>new o.Vector3(0,0,-1))),[z]=i.useState((()=>new o.Vector4)),[V]=i.useState((()=>new o.Vector3)),[L]=i.useState((()=>new o.Vector3)),[P]=i.useState((()=>new o.Vector4)),[k]=i.useState((()=>new o.Matrix4)),[j]=i.useState((()=>new o.PerspectiveCamera)),O=i.useCallback((()=>{var e;const t=M.current.parent||(null==(e=M.current)?void 0:e.__r3f.parent);if(!t)return;if(R.setFromMatrixPosition(t.matrixWorld),C.setFromMatrixPosition(U.matrixWorld),E.extractRotation(t.matrixWorld),b.set(0,0,1),b.applyMatrix4(E),R.addScaledVector(b,S),V.subVectors(R,C),V.dot(b)>0)return;V.reflect(b).negate(),V.add(R),E.extractRotation(U.matrixWorld),A.set(0,0,-1),A.applyMatrix4(E),A.add(C),L.subVectors(R,A),L.reflect(b).negate(),L.add(R),j.position.copy(V),j.up.set(0,1,0),j.up.applyMatrix4(E),j.up.reflect(b),j.lookAt(L),j.far=U.far,j.updateMatrixWorld(),j.projectionMatrix.copy(U.projectionMatrix),k.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),k.multiply(j.projectionMatrix),k.multiply(j.matrixWorldInverse),k.multiply(t.matrixWorld),F.setFromNormalAndCoplanarPoint(b,R),F.applyMatrix4(j.matrixWorldInverse),z.set(F.normal.x,F.normal.y,F.normal.z,F.constant);const r=j.projectionMatrix;P.x=(Math.sign(z.x)+r.elements[8])/r.elements[0],P.y=(Math.sign(z.y)+r.elements[9])/r.elements[5],P.z=-1,P.w=(1+r.elements[10])/r.elements[14],z.multiplyScalar(2/z.dot(P)),r.elements[2]=z.x,r.elements[6]=z.y,r.elements[10]=z.z+1,r.elements[14]=z.w}),[U,S]),[I,W,N,H]=i.useMemo((()=>{const e={minFilter:o.LinearFilter,magFilter:o.LinearFilter,type:o.HalfFloatType},t=new o.WebGLRenderTarget(u,u,e);t.depthBuffer=!0,t.depthTexture=new o.DepthTexture(u,u),t.depthTexture.format=o.DepthFormat,t.depthTexture.type=o.UnsignedShortType;const n=new o.WebGLRenderTarget(u,u,e);return[t,n,new h({gl:B,resolution:u,width:m[0],height:m[1],minDepthThreshold:f,maxDepthThreshold:c,depthScale:v,depthToBlurRatioBias:p}),{mirror:x,textureMatrix:k,mixBlur:r,tDiffuse:t.texture,tDepth:t.depthTexture,tDiffuseBlur:n.texture,hasBlur:w,mixStrength:l,minDepthThreshold:f,maxDepthThreshold:c,depthScale:v,depthToBlurRatioBias:p,distortion:g,distortionMap:T,mixContrast:_,"defines-USE_BLUR":w?"":void 0,"defines-USE_DEPTH":v>0?"":void 0,"defines-USE_DISTORTION":T?"":void 0}]}),[B,m,k,u,x,w,r,l,f,c,v,p,g,T,_]);return(0,a.C)((()=>{var e;const t=M.current.parent||(null==(e=M.current)?void 0:e.__r3f.parent);if(!t)return;t.visible=!1;const r=B.xr.enabled,n=B.shadowMap.autoUpdate;O(),B.xr.enabled=!1,B.shadowMap.autoUpdate=!1,B.setRenderTarget(I),B.state.buffers.depth.setMask(!0),B.autoClear||B.clear(),B.render(y,j),w&&N.render(B,I,W),B.xr.enabled=r,B.shadowMap.autoUpdate=n,t.visible=!0,B.setRenderTarget(null)})),i.createElement("meshReflectorMaterialImpl",(0,n.Z)({attach:"material",key:"key"+H["defines-USE_BLUR"]+H["defines-USE_DEPTH"]+H["defines-USE_DISTORTION"],ref:(0,s.Z)([M,t])},H,D))}))},126:(e,t,r)=>{r.d(t,{x:()=>s});var n=r(7462),i=r(7313),o=r(3002),a=r(1120);const s=i.forwardRef(((e,t)=>{let{sdfGlyphSize:s=64,anchorX:l="center",anchorY:u="middle",font:h,fontSize:d=1,children:m,characters:f,onSync:c,...v}=e;const{Text:p,preloadFont:x}=(0,a.Rq)((async()=>r.e(109).then(r.bind(r,109))),[]),g=(0,o.A)((e=>{let{invalidate:t}=e;return t})),[_]=i.useState((()=>new p)),[T,S]=i.useMemo((()=>{const e=[];let t="";return i.Children.forEach(m,(r=>{"string"===typeof r||"number"===typeof r?t+=r:e.push(r)})),[e,t]}),[m]);return(0,a.Rq)((()=>new Promise((e=>x({font:h,characters:f},e)))),["troika-text",h,f]),i.useLayoutEffect((()=>{_.sync((()=>{g(),c&&c(_)}))})),i.useEffect((()=>()=>_.dispose()),[_]),i.createElement("primitive",(0,n.Z)({object:_,ref:t,font:h,text:S,anchorX:l,anchorY:u,fontSize:d,sdfGlyphSize:s},v),T)}))},2952:(e,t,r)=>{r.d(t,{Ab:()=>u,Cd:()=>s,FC:()=>p,FM:()=>v,JO:()=>d,KC:()=>m,N1:()=>g,Qq:()=>l,aL:()=>h,fg:()=>f,vO:()=>c,xu:()=>a,yI:()=>x});var n=r(7462),i=r(7313);function o(e,t){const r=e+"Geometry";return i.forwardRef(((e,o)=>{let{args:a,children:s,...l}=e;const u=i.useRef(null);return i.useImperativeHandle(o,(()=>u.current)),i.useLayoutEffect((()=>{null==t||t(u.current)})),i.createElement("mesh",(0,n.Z)({ref:u},l),i.createElement(r,{attach:"geometry",args:a}),s)}))}const a=o("box"),s=o("circle"),l=o("cone"),u=o("cylinder"),h=o("sphere"),d=o("plane"),m=o("torus"),f=o("torusKnot"),c=o("tetrahedron"),v=o("ring"),p=o("icosahedron"),x=o("octahedron"),g=o("dodecahedron")},8640:(e,t,r)=>{r.d(t,{m:()=>s});var n=r(5825),i=r(3002),o=r(7313);const a=e=>e===Object(e)&&!Array.isArray(e)&&"function"!==typeof e;function s(e,t){const r=(0,i.A)((e=>e.gl)),s=(0,i.F)(n.TextureLoader,a(e)?Object.values(e):e);if((0,o.useLayoutEffect)((()=>{null==t||t(s)}),[t]),(0,o.useEffect)((()=>{if("initTexture"in r){(Array.isArray(s)?s:[s]).forEach(r.initTexture)}}),[r,s]),a(e)){const t={};let r=0;for(const n in e)t[n]=s[r++];return t}return s}s.preload=e=>i.F.preload(n.TextureLoader,e),s.clear=e=>i.F.clear(n.TextureLoader,e)}}]);