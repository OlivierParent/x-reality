"use strict";(self.webpackChunkx_reality=self.webpackChunkx_reality||[]).push([[9822],{3081:(t,e,n)=>{n.d(e,{P:()=>f});var r=n(7462),o=n(7313),i=n(5825),a=n(3002),s=n(4296),l=n(2362);class c extends i.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new i.Vector3(0,0,0)},lightColor:{value:new i.Color("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new i.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      ",fragmentShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <".concat(l.i>=154?"colorspace_fragment":"encodings_fragment",">\n        }\n      ")})}}function u(t){let{opacity:e=1,radiusTop:n,radiusBottom:r,depthBuffer:s,color:l="white",distance:u=5,angle:f=.15,attenuation:y=5,anglePower:p=5}=t;const h=o.useRef(null),d=(0,a.A)((t=>t.size)),m=(0,a.A)((t=>t.camera)),g=(0,a.A)((t=>t.viewport.dpr)),[x]=o.useState((()=>new c)),[b]=o.useState((()=>new i.Vector3));n=void 0===n?.1:n,r=void 0===r?7*f:r,(0,a.C)((()=>{x.uniforms.spotPosition.value.copy(h.current.getWorldPosition(b)),h.current.lookAt(h.current.parent.target.getWorldPosition(b))}));const v=o.useMemo((()=>{const t=new i.CylinderGeometry(n,r,u,128,64,!0);return t.applyMatrix4((new i.Matrix4).makeTranslation(0,-u/2,0)),t.applyMatrix4((new i.Matrix4).makeRotationX(-Math.PI/2)),t}),[u,n,r]);return o.createElement(o.Fragment,null,o.createElement("mesh",{ref:h,geometry:v,raycast:()=>null},o.createElement("primitive",{object:x,attach:"material","uniforms-opacity-value":e,"uniforms-lightColor-value":l,"uniforms-attenuation-value":y,"uniforms-anglePower-value":p,"uniforms-depth-value":s,"uniforms-cameraNear-value":m.near,"uniforms-cameraFar-value":m.far,"uniforms-resolution-value":s?[d.width*g,d.height*g]:[0,0]})))}const f=o.forwardRef(((t,e)=>{let{opacity:n=1,radiusTop:i,radiusBottom:a,depthBuffer:l,color:c="white",distance:f=5,angle:y=.15,attenuation:p=5,anglePower:h=5,volumetric:d=!0,debug:m=!1,children:g,...x}=t;const b=o.useRef(null);return o.createElement("group",null,m&&b.current&&o.createElement("spotLightHelper",{args:[b.current]}),o.createElement("spotLight",(0,r.Z)({ref:(0,s.Z)([e,b]),angle:y,color:c,distance:f,castShadow:!0},x),d&&o.createElement(u,{debug:m,opacity:n,radiusTop:i,radiusBottom:a,depthBuffer:l,color:c,distance:f,angle:y,attenuation:p,anglePower:h})),g&&o.cloneElement(g,{spotlightRef:b,debug:m}))}))},848:(t,e,n)=>{n.d(e,{n:()=>l});var r=n(7462),o=n(3002),i=n(7313),a=n(5825);class s extends a.Loader{constructor(t){super(t),this.defaultDPI=90,this.defaultUnit="px"}load(t,e,n,r){const o=this,i=new a.FileLoader(o.manager);i.setPath(o.path),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials),i.load(t,(function(n){try{e(o.parse(n))}catch(i){r?r(i):console.error(i),o.manager.itemError(t)}}),n,r)}parse(t){const e=this;function n(t,e,n,o,i,a,s,l){if(0==e||0==n)return void t.lineTo(l.x,l.y);o=o*Math.PI/180,e=Math.abs(e),n=Math.abs(n);const c=(s.x-l.x)/2,u=(s.y-l.y)/2,f=Math.cos(o)*c+Math.sin(o)*u,y=-Math.sin(o)*c+Math.cos(o)*u;let p=e*e,h=n*n;const d=f*f,m=y*y,g=d/p+m/h;if(g>1){const t=Math.sqrt(g);p=(e*=t)*e,h=(n*=t)*n}const x=p*m+h*d,b=(p*h-x)/x;let v=Math.sqrt(Math.max(0,b));i===a&&(v=-v);const w=v*e*y/n,k=-v*n*f/e,A=Math.cos(o)*w-Math.sin(o)*k+(s.x+l.x)/2,P=Math.sin(o)*w+Math.cos(o)*k+(s.y+l.y)/2,M=r(1,0,(f-w)/e,(y-k)/n),T=r((f-w)/e,(y-k)/n,(-f-w)/e,(-y-k)/n)%(2*Math.PI);t.currentPath.absellipse(A,P,e,n,M,M+T,0===a,o)}function r(t,e,n,r){const o=t*n+e*r,i=Math.sqrt(t*t+e*e)*Math.sqrt(n*n+r*r);let a=Math.acos(Math.max(-1,Math.min(1,o/i)));return t*r-e*n<0&&(a=-a),a}function o(t,e){e=Object.assign({},e);let n={};if(t.hasAttribute("class")){const e=t.getAttribute("class").split(/\s/).filter(Boolean).map((t=>t.trim()));for(let t=0;t<e.length;t++)n=Object.assign(n,h["."+e[t]])}function r(r,o,i){void 0===i&&(i=function(t){return t.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),t}),t.hasAttribute(r)&&(e[o]=i(t.getAttribute(r))),n[r]&&(e[o]=i(n[r])),t.style&&""!==t.style[r]&&(e[o]=i(t.style[r]))}function o(t){return Math.max(0,Math.min(1,u(t)))}function i(t){return Math.max(0,u(t))}return t.hasAttribute("id")&&(n=Object.assign(n,h["#"+t.getAttribute("id")])),r("fill","fill"),r("fill-opacity","fillOpacity",o),r("fill-rule","fillRule"),r("opacity","opacity",o),r("stroke","stroke"),r("stroke-opacity","strokeOpacity",o),r("stroke-width","strokeWidth",i),r("stroke-linejoin","strokeLineJoin"),r("stroke-linecap","strokeLineCap"),r("stroke-miterlimit","strokeMiterLimit",i),r("visibility","visibility"),e}function i(t,e){return t-(e-t)}function s(t,e,n){if("string"!==typeof t)throw new TypeError("Invalid input: "+typeof t);const r={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/};let o=0,i=!0,a="",s="";const l=[];function c(t,e,n){const r=new SyntaxError('Unexpected character "'+t+'" at index '+e+".");throw r.partial=n,r}function u(){""!==a&&(""===s?l.push(Number(a)):l.push(Number(a)*Math.pow(10,Number(s)))),a="",s=""}let f;const y=t.length;for(let p=0;p<y;p++)if(f=t[p],Array.isArray(e)&&e.includes(l.length%n)&&r.FLAGS.test(f))o=1,a=f,u();else{if(0===o){if(r.WHITESPACE.test(f))continue;if(r.DIGIT.test(f)||r.SIGN.test(f)){o=1,a=f;continue}if(r.POINT.test(f)){o=2,a=f;continue}r.COMMA.test(f)&&(i&&c(f,p,l),i=!0)}if(1===o){if(r.DIGIT.test(f)){a+=f;continue}if(r.POINT.test(f)){a+=f,o=2;continue}if(r.EXP.test(f)){o=3;continue}r.SIGN.test(f)&&1===a.length&&r.SIGN.test(a[0])&&c(f,p,l)}if(2===o){if(r.DIGIT.test(f)){a+=f;continue}if(r.EXP.test(f)){o=3;continue}r.POINT.test(f)&&"."===a[a.length-1]&&c(f,p,l)}if(3===o){if(r.DIGIT.test(f)){s+=f;continue}if(r.SIGN.test(f)){if(""===s){s+=f;continue}1===s.length&&r.SIGN.test(s)&&c(f,p,l)}}r.WHITESPACE.test(f)?(u(),o=0,i=!1):r.COMMA.test(f)?(u(),o=0,i=!0):r.SIGN.test(f)?(u(),o=1,a=f):r.POINT.test(f)?(u(),o=2,a=f):c(f,p,l)}return u(),l}const l=["mm","cm","in","pt","pc","px"],c={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function u(t){let n,r="px";if("string"===typeof t||t instanceof String)for(let e=0,o=l.length;e<o;e++){const n=l[e];if(t.endsWith(n)){r=n,t=t.substring(0,t.length-n.length);break}}return"px"===r&&"px"!==e.defaultUnit?n=c.in[e.defaultUnit]/e.defaultDPI:(n=c[r][e.defaultUnit],n<0&&(n=c[r].in*e.defaultDPI)),n*parseFloat(t)}function f(t){const e=t.elements;return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function y(t){const e=t.elements;return Math.sqrt(e[3]*e[3]+e[4]*e[4])}const p=[],h={},d=[],m=new a.Matrix3,g=new a.Matrix3,x=new a.Matrix3,b=new a.Matrix3,v=new a.Vector2,w=new a.Vector3,k=new a.Matrix3,A=(new DOMParser).parseFromString(t,"image/svg+xml");!function t(e,r){if(1!==e.nodeType)return;const l=function(t){if(!(t.hasAttribute("transform")||"use"===t.nodeName&&(t.hasAttribute("x")||t.hasAttribute("y"))))return null;const e=function(t){const e=new a.Matrix3,n=m;if("use"===t.nodeName&&(t.hasAttribute("x")||t.hasAttribute("y"))){const n=u(t.getAttribute("x")),r=u(t.getAttribute("y"));e.translate(n,r)}if(t.hasAttribute("transform")){const r=t.getAttribute("transform").split(")");for(let t=r.length-1;t>=0;t--){const o=r[t].trim();if(""===o)continue;const i=o.indexOf("("),a=o.length;if(i>0&&i<a){const t=o.substr(0,i),e=s(o.substr(i+1,a-i-1));switch(n.identity(),t){case"translate":if(e.length>=1){const t=e[0];let r=t;e.length>=2&&(r=e[1]),n.translate(t,r)}break;case"rotate":if(e.length>=1){let t=0,r=0,o=0;t=-e[0]*Math.PI/180,e.length>=3&&(r=e[1],o=e[2]),g.identity().translate(-r,-o),x.identity().rotate(t),b.multiplyMatrices(x,g),g.identity().translate(r,o),n.multiplyMatrices(g,b)}break;case"scale":if(e.length>=1){const t=e[0];let r=t;e.length>=2&&(r=e[1]),n.scale(t,r)}break;case"skewX":1===e.length&&n.set(1,Math.tan(e[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===e.length&&n.set(1,0,0,Math.tan(e[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===e.length&&n.set(e[0],e[2],e[4],e[1],e[3],e[5],0,0,1)}}e.premultiply(n)}}return e}(t);d.length>0&&e.premultiply(d[d.length-1]);return k.copy(e),d.push(e),e}(e);let c=!0,A=null;switch(e.nodeName){case"svg":break;case"style":!function(t){if(!t.sheet||!t.sheet.cssRules||!t.sheet.cssRules.length)return;for(let e=0;e<t.sheet.cssRules.length;e++){const n=t.sheet.cssRules[e];if(1!==n.type)continue;const r=n.selectorText.split(/,/gm).filter(Boolean).map((t=>t.trim()));for(let t=0;t<r.length;t++)h[r[t]]=Object.assign(h[r[t]]||{},n.style)}}(e);break;case"g":r=o(e,r);break;case"path":r=o(e,r),e.hasAttribute("d")&&(A=function(t){const e=new a.ShapePath,r=new a.Vector2,o=new a.Vector2,l=new a.Vector2;let c=!0,u=!1;const f=t.getAttribute("d"),y=f.match(/[a-df-z][^a-df-z]*/gi);for(let a=0,p=y.length;a<p;a++){const t=y[a],f=t.charAt(0),p=t.substr(1).trim();let h;switch(!0===c&&(u=!0,c=!1),f){case"M":h=s(p);for(let t=0,n=h.length;t<n;t+=2)r.x=h[t+0],r.y=h[t+1],o.x=r.x,o.y=r.y,0===t?e.moveTo(r.x,r.y):e.lineTo(r.x,r.y),0===t&&l.copy(r);break;case"H":h=s(p);for(let t=0,n=h.length;t<n;t++)r.x=h[t],o.x=r.x,o.y=r.y,e.lineTo(r.x,r.y),0===t&&!0===u&&l.copy(r);break;case"V":h=s(p);for(let t=0,n=h.length;t<n;t++)r.y=h[t],o.x=r.x,o.y=r.y,e.lineTo(r.x,r.y),0===t&&!0===u&&l.copy(r);break;case"L":h=s(p);for(let t=0,n=h.length;t<n;t+=2)r.x=h[t+0],r.y=h[t+1],o.x=r.x,o.y=r.y,e.lineTo(r.x,r.y),0===t&&!0===u&&l.copy(r);break;case"C":h=s(p);for(let t=0,n=h.length;t<n;t+=6)e.bezierCurveTo(h[t+0],h[t+1],h[t+2],h[t+3],h[t+4],h[t+5]),o.x=h[t+2],o.y=h[t+3],r.x=h[t+4],r.y=h[t+5],0===t&&!0===u&&l.copy(r);break;case"S":h=s(p);for(let t=0,n=h.length;t<n;t+=4)e.bezierCurveTo(i(r.x,o.x),i(r.y,o.y),h[t+0],h[t+1],h[t+2],h[t+3]),o.x=h[t+0],o.y=h[t+1],r.x=h[t+2],r.y=h[t+3],0===t&&!0===u&&l.copy(r);break;case"Q":h=s(p);for(let t=0,n=h.length;t<n;t+=4)e.quadraticCurveTo(h[t+0],h[t+1],h[t+2],h[t+3]),o.x=h[t+0],o.y=h[t+1],r.x=h[t+2],r.y=h[t+3],0===t&&!0===u&&l.copy(r);break;case"T":h=s(p);for(let t=0,n=h.length;t<n;t+=2){const n=i(r.x,o.x),a=i(r.y,o.y);e.quadraticCurveTo(n,a,h[t+0],h[t+1]),o.x=n,o.y=a,r.x=h[t+0],r.y=h[t+1],0===t&&!0===u&&l.copy(r)}break;case"A":h=s(p,[3,4],7);for(let t=0,i=h.length;t<i;t+=7){if(h[t+5]==r.x&&h[t+6]==r.y)continue;const i=r.clone();r.x=h[t+5],r.y=h[t+6],o.x=r.x,o.y=r.y,n(e,h[t],h[t+1],h[t+2],h[t+3],h[t+4],i,r),0===t&&!0===u&&l.copy(r)}break;case"m":h=s(p);for(let t=0,n=h.length;t<n;t+=2)r.x+=h[t+0],r.y+=h[t+1],o.x=r.x,o.y=r.y,0===t?e.moveTo(r.x,r.y):e.lineTo(r.x,r.y),0===t&&l.copy(r);break;case"h":h=s(p);for(let t=0,n=h.length;t<n;t++)r.x+=h[t],o.x=r.x,o.y=r.y,e.lineTo(r.x,r.y),0===t&&!0===u&&l.copy(r);break;case"v":h=s(p);for(let t=0,n=h.length;t<n;t++)r.y+=h[t],o.x=r.x,o.y=r.y,e.lineTo(r.x,r.y),0===t&&!0===u&&l.copy(r);break;case"l":h=s(p);for(let t=0,n=h.length;t<n;t+=2)r.x+=h[t+0],r.y+=h[t+1],o.x=r.x,o.y=r.y,e.lineTo(r.x,r.y),0===t&&!0===u&&l.copy(r);break;case"c":h=s(p);for(let t=0,n=h.length;t<n;t+=6)e.bezierCurveTo(r.x+h[t+0],r.y+h[t+1],r.x+h[t+2],r.y+h[t+3],r.x+h[t+4],r.y+h[t+5]),o.x=r.x+h[t+2],o.y=r.y+h[t+3],r.x+=h[t+4],r.y+=h[t+5],0===t&&!0===u&&l.copy(r);break;case"s":h=s(p);for(let t=0,n=h.length;t<n;t+=4)e.bezierCurveTo(i(r.x,o.x),i(r.y,o.y),r.x+h[t+0],r.y+h[t+1],r.x+h[t+2],r.y+h[t+3]),o.x=r.x+h[t+0],o.y=r.y+h[t+1],r.x+=h[t+2],r.y+=h[t+3],0===t&&!0===u&&l.copy(r);break;case"q":h=s(p);for(let t=0,n=h.length;t<n;t+=4)e.quadraticCurveTo(r.x+h[t+0],r.y+h[t+1],r.x+h[t+2],r.y+h[t+3]),o.x=r.x+h[t+0],o.y=r.y+h[t+1],r.x+=h[t+2],r.y+=h[t+3],0===t&&!0===u&&l.copy(r);break;case"t":h=s(p);for(let t=0,n=h.length;t<n;t+=2){const n=i(r.x,o.x),a=i(r.y,o.y);e.quadraticCurveTo(n,a,r.x+h[t+0],r.y+h[t+1]),o.x=n,o.y=a,r.x=r.x+h[t+0],r.y=r.y+h[t+1],0===t&&!0===u&&l.copy(r)}break;case"a":h=s(p,[3,4],7);for(let t=0,i=h.length;t<i;t+=7){if(0==h[t+5]&&0==h[t+6])continue;const i=r.clone();r.x+=h[t+5],r.y+=h[t+6],o.x=r.x,o.y=r.y,n(e,h[t],h[t+1],h[t+2],h[t+3],h[t+4],i,r),0===t&&!0===u&&l.copy(r)}break;case"Z":case"z":e.currentPath.autoClose=!0,e.currentPath.curves.length>0&&(r.copy(l),e.currentPath.currentPoint.copy(r),c=!0);break;default:console.warn(t)}u=!1}return e}(e));break;case"rect":r=o(e,r),A=function(t){const e=u(t.getAttribute("x")||0),n=u(t.getAttribute("y")||0),r=u(t.getAttribute("rx")||t.getAttribute("ry")||0),o=u(t.getAttribute("ry")||t.getAttribute("rx")||0),i=u(t.getAttribute("width")),s=u(t.getAttribute("height")),l=.448084975506,c=new a.ShapePath;c.moveTo(e+r,n),c.lineTo(e+i-r,n),(0!==r||0!==o)&&c.bezierCurveTo(e+i-r*l,n,e+i,n+o*l,e+i,n+o);c.lineTo(e+i,n+s-o),(0!==r||0!==o)&&c.bezierCurveTo(e+i,n+s-o*l,e+i-r*l,n+s,e+i-r,n+s);c.lineTo(e+r,n+s),(0!==r||0!==o)&&c.bezierCurveTo(e+r*l,n+s,e,n+s-o*l,e,n+s-o);c.lineTo(e,n+o),(0!==r||0!==o)&&c.bezierCurveTo(e,n+o*l,e+r*l,n,e+r,n);return c}(e);break;case"polygon":r=o(e,r),A=function(t){function e(t,e,n){const i=u(e),a=u(n);0===o?r.moveTo(i,a):r.lineTo(i,a),o++}const n=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,r=new a.ShapePath;let o=0;return t.getAttribute("points").replace(n,e),r.currentPath.autoClose=!0,r}(e);break;case"polyline":r=o(e,r),A=function(t){function e(t,e,n){const i=u(e),a=u(n);0===o?r.moveTo(i,a):r.lineTo(i,a),o++}const n=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,r=new a.ShapePath;let o=0;return t.getAttribute("points").replace(n,e),r.currentPath.autoClose=!1,r}(e);break;case"circle":r=o(e,r),A=function(t){const e=u(t.getAttribute("cx")||0),n=u(t.getAttribute("cy")||0),r=u(t.getAttribute("r")||0),o=new a.Path;o.absarc(e,n,r,0,2*Math.PI);const i=new a.ShapePath;return i.subPaths.push(o),i}(e);break;case"ellipse":r=o(e,r),A=function(t){const e=u(t.getAttribute("cx")||0),n=u(t.getAttribute("cy")||0),r=u(t.getAttribute("rx")||0),o=u(t.getAttribute("ry")||0),i=new a.Path;i.absellipse(e,n,r,o,0,2*Math.PI);const s=new a.ShapePath;return s.subPaths.push(i),s}(e);break;case"line":r=o(e,r),A=function(t){const e=u(t.getAttribute("x1")||0),n=u(t.getAttribute("y1")||0),r=u(t.getAttribute("x2")||0),o=u(t.getAttribute("y2")||0),i=new a.ShapePath;return i.moveTo(e,n),i.lineTo(r,o),i.currentPath.autoClose=!1,i}(e);break;case"defs":case"mask":c=!1;break;case"use":r=o(e,r);const l=e.href.baseVal.substring(1),f=e.viewportElement.getElementById(l);f?t(f,r):console.warn("SVGLoader: 'use node' references non-existent node id: "+l)}if(A&&(void 0!==r.fill&&"none"!==r.fill&&A.color.setStyle(r.fill),function(t,e){function n(t){w.set(t.x,t.y,1).applyMatrix3(e),t.set(w.x,w.y)}const r=function(t){return 0!==t.elements[1]||0!==t.elements[3]}(e),o=t.subPaths;for(let i=0,a=o.length;i<a;i++){const t=o[i].curves;for(let o=0;o<t.length;o++){const i=t[o];i.isLineCurve?(n(i.v1),n(i.v2)):i.isCubicBezierCurve?(n(i.v0),n(i.v1),n(i.v2),n(i.v3)):i.isQuadraticBezierCurve?(n(i.v0),n(i.v1),n(i.v2)):i.isEllipseCurve&&(r&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),v.set(i.aX,i.aY),n(v),i.aX=v.x,i.aY=v.y,i.xRadius*=f(e),i.yRadius*=y(e))}}}(A,k),p.push(A),A.userData={node:e,style:r}),c){const n=e.childNodes;for(let e=0;e<n.length;e++)t(n[e],r)}l&&(d.pop(),d.length>0?k.copy(d[d.length-1]):k.identity())}(A.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4});return{paths:p,xml:A.documentElement}}static createShapes(t){const e=999999999,n=0,r=1,o=2,i=3,s=4,l=5,c=6,u={loc:n,t:0};function f(t,e,r,i){const a=t.x,s=e.x,l=r.x,c=i.x,f=t.y,p=e.y,h=r.y,d=i.y,m=(c-l)*(f-h)-(d-h)*(a-l),g=(d-h)*(s-a)-(c-l)*(p-f),x=m/g,b=((s-a)*(f-h)-(p-f)*(a-l))/g;if(0===g&&0!==m||x<=0||x>=1||b<0||b>1)return null;if(0===m&&0===g){for(let l=0;l<2;l++){if(y(0===l?r:i,t,e),u.loc==n){const t=0===l?r:i;return{x:t.x,y:t.y,t:u.t}}if(u.loc==o){return{x:+(a+u.t*(s-a)).toPrecision(10),y:+(f+u.t*(p-f)).toPrecision(10),t:u.t}}}return null}for(let o=0;o<2;o++)if(y(0===o?r:i,t,e),u.loc==n){const t=0===o?r:i;return{x:t.x,y:t.y,t:u.t}}return{x:+(a+x*(s-a)).toPrecision(10),y:+(f+x*(p-f)).toPrecision(10),t:x}}function y(t,e,a){const f=a.x-e.x,y=a.y-e.y,p=t.x-e.x,h=t.y-e.y,d=f*h-p*y;if(t.x===e.x&&t.y===e.y)return u.loc=n,void(u.t=0);if(t.x===a.x&&t.y===a.y)return u.loc=r,void(u.t=1);if(d<-Number.EPSILON)return void(u.loc=i);if(d>Number.EPSILON)return void(u.loc=s);if(f*p<0||y*h<0)return void(u.loc=l);if(Math.sqrt(f*f+y*y)<Math.sqrt(p*p+h*h))return void(u.loc=c);let m;m=0!==f?p/f:h/y,u.loc=o,u.t=m}function p(t,e,n){const r=new a.Vector2;e.getCenter(r);const o=[];return n.forEach((e=>{if(e.boundingBox.containsPoint(r)){(function(t,e){const n=[],r=[];for(let o=1;o<t.length;o++){const i=t[o-1],s=t[o];for(let t=1;t<e.length;t++){const o=f(i,s,e[t-1],e[t]);null!==o&&void 0===n.find((t=>t.t<=o.t+Number.EPSILON&&t.t>=o.t-Number.EPSILON))&&(n.push(o),r.push(new a.Vector2(o.x,o.y)))}}return r})(t,e.points).forEach((t=>{o.push({identifier:e.identifier,isCW:e.isCW,point:t})}))}})),o.sort(((t,e)=>t.point.x-e.point.x)),o}let h=0,d=e,m=-999999999,g=t.subPaths.map((t=>{const n=t.getPoints();let r=-999999999,o=e,i=-999999999,s=e;for(let e=0;e<n.length;e++){const t=n[e];t.y>r&&(r=t.y),t.y<o&&(o=t.y),t.x>i&&(i=t.x),t.x<s&&(s=t.x)}return m<=i&&(m=i+1),d>=s&&(d=s-1),{curves:t.curves,points:n,isCW:a.ShapeUtils.isClockWise(n),identifier:h++,boundingBox:new a.Box2(new a.Vector2(s,o),new a.Vector2(i,r))}}));g=g.filter((t=>t.points.length>1));const x=g.map((e=>function(t,e,n,r,o){null!==o&&void 0!==o&&""!==o||(o="nonzero");const i=new a.Vector2;t.boundingBox.getCenter(i);const s=p([new a.Vector2(n,i.y),new a.Vector2(r,i.y)],t.boundingBox,e);s.sort(((t,e)=>t.point.x-e.point.x));const l=[],c=[];s.forEach((e=>{e.identifier===t.identifier?l.push(e):c.push(e)}));const u=l[0].point.x,f=[];let y=0;for(;y<c.length&&c[y].point.x<u;)f.length>0&&f[f.length-1]===c[y].identifier?f.pop():f.push(c[y].identifier),y++;if(f.push(t.identifier),"evenodd"===o){const e=f.length%2===0,n=f[f.length-2];return{identifier:t.identifier,isHole:e,for:n}}if("nonzero"===o){let n=!0,r=null,o=null;for(let t=0;t<f.length;t++){const i=f[t];n?(o=e[i].isCW,n=!1,r=i):o!==e[i].isCW&&(o=e[i].isCW,n=!0)}return{identifier:t.identifier,isHole:n,for:r}}console.warn('fill-rule: "'+o+'" is currently not implemented.')}(e,g,d,m,t.userData.style.fillRule))),b=[];return g.forEach((t=>{if(!x[t.identifier].isHole){const e=new a.Shape;e.curves=t.curves;x.filter((e=>e.isHole&&e.for===t.identifier)).forEach((t=>{const n=g[t.identifier],r=new a.Path;r.curves=n.curves,e.holes.push(r)})),b.push(e)}})),b}static getStrokeStyle(t,e,n,r,o){return{strokeColor:e=void 0!==e?e:"#000",strokeWidth:t=void 0!==t?t:1,strokeLineJoin:n=void 0!==n?n:"miter",strokeLineCap:r=void 0!==r?r:"butt",strokeMiterLimit:o=void 0!==o?o:4}}static pointsToStroke(t,e,n,r){const o=[],i=[],l=[];if(0===s.pointsToStrokeWithBuffers(t,e,n,r,o,i,l))return null;const c=new a.BufferGeometry;return c.setAttribute("position",new a.Float32BufferAttribute(o,3)),c.setAttribute("normal",new a.Float32BufferAttribute(i,3)),c.setAttribute("uv",new a.Float32BufferAttribute(l,2)),c}static pointsToStrokeWithBuffers(t,e,n,r,o,i,s,l){const c=new a.Vector2,u=new a.Vector2,f=new a.Vector2,y=new a.Vector2,p=new a.Vector2,h=new a.Vector2,d=new a.Vector2,m=new a.Vector2,g=new a.Vector2,x=new a.Vector2,b=new a.Vector2,v=new a.Vector2,w=new a.Vector2,k=new a.Vector2,A=new a.Vector2,P=new a.Vector2,M=new a.Vector2;n=void 0!==n?n:12,r=void 0!==r?r:.001,l=void 0!==l?l:0;const T=(t=function(t){let e=!1;for(let o=1,i=t.length-1;o<i;o++)if(t[o].distanceTo(t[o+1])<r){e=!0;break}if(!e)return t;const n=[];n.push(t[0]);for(let o=1,i=t.length-1;o<i;o++)t[o].distanceTo(t[o+1])>=r&&n.push(t[o]);return n.push(t[t.length-1]),n}(t)).length;if(T<2)return 0;const S=t[0].equals(t[T-1]);let C,V,E=t[0];const I=e.strokeWidth/2,N=1/(T-1);let L,D,O,z,B=0,W=!1,F=0,G=3*l,R=2*l;Z(t[0],t[1],c).multiplyScalar(I),m.copy(t[0]).sub(c),g.copy(t[0]).add(c),x.copy(m),b.copy(g);for(let a=1;a<T;a++){C=t[a],V=a===T-1?S?t[1]:void 0:t[a+1];const n=c;if(Z(E,C,n),f.copy(n).multiplyScalar(I),v.copy(C).sub(f),w.copy(C).add(f),L=B+N,D=!1,void 0!==V){Z(C,V,u),f.copy(u).multiplyScalar(I),k.copy(C).sub(f),A.copy(C).add(f),O=!0,f.subVectors(V,E),n.dot(f)<0&&(O=!1),1===a&&(W=O),f.subVectors(V,C),f.normalize();const t=Math.abs(n.dot(f));if(0!==t){const n=I/t;f.multiplyScalar(-n),y.subVectors(C,E),p.copy(y).setLength(n).add(f),P.copy(p).negate();const r=p.length(),o=y.length();y.divideScalar(o),h.subVectors(V,C);const i=h.length();switch(h.divideScalar(i),y.dot(P)<o&&h.dot(P)<i&&(D=!0),M.copy(p).add(C),P.add(C),z=!1,D?O?(A.copy(P),w.copy(P)):(k.copy(P),v.copy(P)):H(),e.strokeLineJoin){case"bevel":j(O,D,L);break;case"round":U(O,D),O?_(C,v,k,L,0):_(C,A,w,L,1);break;default:const t=I*e.strokeMiterLimit/r;if(t<1){if("miter-clip"!==e.strokeLineJoin){j(O,D,L);break}U(O,D),O?(h.subVectors(M,v).multiplyScalar(t).add(v),d.subVectors(M,k).multiplyScalar(t).add(k),q(v,L,0),q(h,L,0),q(C,L,.5),q(C,L,.5),q(h,L,0),q(d,L,0),q(C,L,.5),q(d,L,0),q(k,L,0)):(h.subVectors(M,w).multiplyScalar(t).add(w),d.subVectors(M,A).multiplyScalar(t).add(A),q(w,L,1),q(h,L,1),q(C,L,.5),q(C,L,.5),q(h,L,1),q(d,L,1),q(C,L,.5),q(d,L,1),q(A,L,1))}else D?(O?(q(g,B,1),q(m,B,0),q(M,L,0),q(g,B,1),q(M,L,0),q(P,L,1)):(q(g,B,1),q(m,B,0),q(M,L,1),q(m,B,0),q(P,L,0),q(M,L,1)),O?k.copy(M):A.copy(M)):O?(q(v,L,0),q(M,L,0),q(C,L,.5),q(C,L,.5),q(M,L,0),q(k,L,0)):(q(w,L,1),q(M,L,1),q(C,L,.5),q(C,L,.5),q(M,L,1),q(A,L,1)),z=!0}}else H()}else H();S||a!==T-1||X(t[0],x,b,O,!0,B),B=L,E=C,m.copy(k),g.copy(A)}if(S){if(D&&o){let t=M,e=P;W!==O&&(t=P,e=M),O?(z||W)&&(e.toArray(o,0),e.toArray(o,9),z&&t.toArray(o,3)):!z&&W||(e.toArray(o,3),e.toArray(o,9),z&&t.toArray(o,0))}}else X(C,v,w,O,!1,L);return F;function Z(t,e,n){return n.subVectors(e,t),n.set(-n.y,n.x).normalize()}function q(t,e,n){o&&(o[G]=t.x,o[G+1]=t.y,o[G+2]=0,i&&(i[G]=0,i[G+1]=0,i[G+2]=1),G+=3,s&&(s[R]=e,s[R+1]=n,R+=2)),F+=3}function _(t,e,r,o,i){c.copy(e).sub(t).normalize(),u.copy(r).sub(t).normalize();let a=Math.PI;const s=c.dot(u);Math.abs(s)<1&&(a=Math.abs(Math.acos(s))),a/=n,f.copy(e);for(let l=0,c=n-1;l<c;l++)y.copy(f).rotateAround(t,a),q(f,o,i),q(y,o,i),q(t,o,.5),f.copy(y);q(y,o,i),q(r,o,i),q(t,o,.5)}function H(){q(g,B,1),q(m,B,0),q(v,L,0),q(g,B,1),q(v,L,1),q(w,L,0)}function j(t,e,n){e?t?(q(g,B,1),q(m,B,0),q(v,L,0),q(g,B,1),q(v,L,0),q(P,L,1),q(v,n,0),q(k,n,0),q(P,n,.5)):(q(g,B,1),q(m,B,0),q(w,L,1),q(m,B,0),q(P,L,0),q(w,L,1),q(w,n,1),q(A,n,0),q(P,n,.5)):t?(q(v,n,0),q(k,n,0),q(C,n,.5)):(q(w,n,1),q(A,n,0),q(C,n,.5))}function U(t,e){e&&(t?(q(g,B,1),q(m,B,0),q(v,L,0),q(g,B,1),q(v,L,0),q(P,L,1),q(v,B,0),q(C,L,.5),q(P,L,1),q(C,L,.5),q(k,B,0),q(P,L,1)):(q(g,B,1),q(m,B,0),q(w,L,1),q(m,B,0),q(P,L,0),q(w,L,1),q(w,B,1),q(P,L,0),q(C,L,.5),q(C,L,.5),q(P,L,0),q(A,B,1)))}function X(t,n,r,i,a,s){switch(e.strokeLineCap){case"round":a?_(t,r,n,s,.5):_(t,n,r,s,.5);break;case"square":if(a)c.subVectors(n,t),u.set(c.y,-c.x),f.addVectors(c,u).add(t),y.subVectors(u,c).add(t),i?(f.toArray(o,3),y.toArray(o,0),y.toArray(o,9)):(f.toArray(o,3),f.toArray(o,9),y.toArray(o,0));else{c.subVectors(r,t),u.set(c.y,-c.x),f.addVectors(c,u).add(t),y.subVectors(u,c).add(t);const e=o.length;i?(f.toArray(o,e-3),y.toArray(o,e-6),y.toArray(o,e-12)):(f.toArray(o,e-6),y.toArray(o,e-3),y.toArray(o,e-12))}}}}}const l=(0,i.forwardRef)((function(t,e){let{src:n,skipFill:l,skipStrokes:c,fillMaterial:u,strokeMaterial:f,fillMeshProps:y,strokeMeshProps:p,...h}=t;const d=(0,o.F)(s,n.startsWith("<svg")?"data:image/svg+xml;utf8,".concat(n):n),m=(0,i.useMemo)((()=>c?[]:d.paths.map((t=>{var e;return void 0===(null==(e=t.userData)?void 0:e.style.stroke)||"none"===t.userData.style.stroke?null:t.subPaths.map((e=>s.pointsToStroke(e.getPoints(),t.userData.style)))}))),[d,c]);return(0,i.useEffect)((()=>()=>m.forEach((t=>t&&t.map((t=>t.dispose()))))),[m]),i.createElement("object3D",(0,r.Z)({ref:e},h),i.createElement("object3D",{scale:[1,-1,1]},d.paths.map(((t,e)=>{var n,o;return i.createElement(i.Fragment,{key:e},!l&&void 0!==(null==(n=t.userData)?void 0:n.style.fill)&&"none"!==t.userData.style.fill&&s.createShapes(t).map(((e,n)=>i.createElement("mesh",(0,r.Z)({key:n},y),i.createElement("shapeGeometry",{args:[e]}),i.createElement("meshBasicMaterial",(0,r.Z)({color:t.userData.style.fill,opacity:t.userData.style.fillOpacity,transparent:!0,side:a.DoubleSide,depthWrite:!1},u))))),!c&&void 0!==(null==(o=t.userData)?void 0:o.style.stroke)&&"none"!==t.userData.style.stroke&&t.subPaths.map(((n,o)=>i.createElement("mesh",(0,r.Z)({key:o,geometry:m[e][o]},p),i.createElement("meshBasicMaterial",(0,r.Z)({color:t.userData.style.stroke,opacity:t.userData.style.strokeOpacity,transparent:!0,side:a.DoubleSide,depthWrite:!1},f))))))}))))}))},5964:(t,e,n)=>{n.d(e,{H:()=>i});var r=n(7313),o=n(3002);function i(t,e){for(var n=arguments.length,i=new Array(n>2?n-2:0),a=2;a<n;a++)i[a-2]=arguments[a];const s=r.useRef(),l=(0,o.A)((t=>t.scene));return r.useLayoutEffect((()=>{let n;if(t&&null!=t&&t.current&&e&&(s.current=n=new e(t.current,...i)),n)return n.traverse((t=>t.raycast=()=>null)),l.add(n),()=>{s.current=void 0,l.remove(n),null==n.dispose||n.dispose()}}),[l,e,t,...i]),(0,o.C)((()=>{var t;null==(t=s.current)||null==t.update||t.update()})),s}},8640:(t,e,n)=>{n.d(e,{m:()=>s});var r=n(5825),o=n(3002),i=n(7313);const a=t=>t===Object(t)&&!Array.isArray(t)&&"function"!==typeof t;function s(t,e){const n=(0,o.A)((t=>t.gl)),s=(0,o.F)(r.TextureLoader,a(t)?Object.values(t):t);if((0,i.useLayoutEffect)((()=>{null==e||e(s)}),[e]),(0,i.useEffect)((()=>{if("initTexture"in n){(Array.isArray(s)?s:[s]).forEach(n.initTexture)}}),[n,s]),a(t)){const e={};let n=0;for(const r in t)e[r]=s[n++];return e}return s}s.preload=t=>o.F.preload(r.TextureLoader,t),s.clear=t=>o.F.clear(r.TextureLoader,t)},2362:(t,e,n)=>{n.d(e,{i:()=>o});var r=n(5825);const o=(()=>parseInt(r.REVISION.replace(/\D+/g,"")))()}}]);